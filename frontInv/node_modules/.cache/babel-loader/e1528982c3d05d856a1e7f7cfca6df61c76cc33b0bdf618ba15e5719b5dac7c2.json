{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/esnext.iterator.constructor.js\");\nrequire(\"core-js/modules/esnext.iterator.filter.js\");\nrequire(\"core-js/modules/esnext.iterator.for-each.js\");\nrequire(\"core-js/modules/esnext.iterator.map.js\");\nrequire(\"core-js/modules/web.url-search-params.delete.js\");\nrequire(\"core-js/modules/web.url-search-params.has.js\");\nrequire(\"core-js/modules/web.url-search-params.size.js\");\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CookieJar = void 0;\nconst getPublicSuffix_1 = require(\"../getPublicSuffix\");\nconst validators = __importStar(require(\"../validators\"));\nconst validators_1 = require(\"../validators\");\nconst store_1 = require(\"../store\");\nconst memstore_1 = require(\"../memstore\");\nconst pathMatch_1 = require(\"../pathMatch\");\nconst cookie_1 = require(\"./cookie\");\nconst utils_1 = require(\"../utils\");\nconst canonicalDomain_1 = require(\"./canonicalDomain\");\nconst constants_1 = require(\"./constants\");\nconst defaultPath_1 = require(\"./defaultPath\");\nconst domainMatch_1 = require(\"./domainMatch\");\nconst cookieCompare_1 = require(\"./cookieCompare\");\nconst version_1 = require(\"../version\");\nconst defaultSetCookieOptions = {\n  loose: false,\n  sameSiteContext: undefined,\n  ignoreError: false,\n  http: true\n};\nconst defaultGetCookieOptions = {\n  http: true,\n  expire: true,\n  allPaths: false,\n  sameSiteContext: undefined,\n  sort: undefined\n};\nconst SAME_SITE_CONTEXT_VAL_ERR = 'Invalid sameSiteContext option for getCookies(); expected one of \"strict\", \"lax\", or \"none\"';\nfunction getCookieContext(url) {\n  if (url && typeof url === 'object' && 'hostname' in url && typeof url.hostname === 'string' && 'pathname' in url && typeof url.pathname === 'string' && 'protocol' in url && typeof url.protocol === 'string') {\n    return {\n      hostname: url.hostname,\n      pathname: url.pathname,\n      protocol: url.protocol\n    };\n  } else if (typeof url === 'string') {\n    try {\n      return new URL(decodeURI(url));\n    } catch {\n      return new URL(url);\n    }\n  } else {\n    throw new validators_1.ParameterError('`url` argument is not a string or URL.');\n  }\n}\nfunction checkSameSiteContext(value) {\n  const context = String(value).toLowerCase();\n  if (context === 'none' || context === 'lax' || context === 'strict') {\n    return context;\n  } else {\n    return undefined;\n  }\n}\n/**\n *  If the cookie-name begins with a case-sensitive match for the\n *  string \"__Secure-\", abort these steps and ignore the cookie\n *  entirely unless the cookie's secure-only-flag is true.\n * @param cookie\n * @returns boolean\n */\nfunction isSecurePrefixConditionMet(cookie) {\n  const startsWithSecurePrefix = typeof cookie.key === 'string' && cookie.key.startsWith('__Secure-');\n  return !startsWithSecurePrefix || cookie.secure;\n}\n/**\n *  If the cookie-name begins with a case-sensitive match for the\n *  string \"__Host-\", abort these steps and ignore the cookie\n *  entirely unless the cookie meets all the following criteria:\n *    1.  The cookie's secure-only-flag is true.\n *    2.  The cookie's host-only-flag is true.\n *    3.  The cookie-attribute-list contains an attribute with an\n *        attribute-name of \"Path\", and the cookie's path is \"/\".\n * @param cookie\n * @returns boolean\n */\nfunction isHostPrefixConditionMet(cookie) {\n  const startsWithHostPrefix = typeof cookie.key === 'string' && cookie.key.startsWith('__Host-');\n  return !startsWithHostPrefix || Boolean(cookie.secure && cookie.hostOnly && cookie.path != null && cookie.path === '/');\n}\nfunction getNormalizedPrefixSecurity(prefixSecurity) {\n  const normalizedPrefixSecurity = prefixSecurity.toLowerCase();\n  /* The three supported options */\n  switch (normalizedPrefixSecurity) {\n    case constants_1.PrefixSecurityEnum.STRICT:\n    case constants_1.PrefixSecurityEnum.SILENT:\n    case constants_1.PrefixSecurityEnum.DISABLED:\n      return normalizedPrefixSecurity;\n    default:\n      return constants_1.PrefixSecurityEnum.SILENT;\n  }\n}\n/**\n * A CookieJar is for storage and retrieval of {@link Cookie} objects as defined in\n * {@link https://www.rfc-editor.org/rfc/rfc6265.html#section-5.3 | RFC6265 - Section 5.3}.\n *\n * It also supports a pluggable persistence layer via {@link Store}.\n * @public\n */\nclass CookieJar {\n  /**\n   * Creates a new `CookieJar` instance.\n   *\n   * @remarks\n   * - If a custom store is not passed to the constructor, an in-memory store ({@link MemoryCookieStore} will be created and used.\n   * - If a boolean value is passed as the `options` parameter, this is equivalent to passing `{ rejectPublicSuffixes: <value> }`\n   *\n   * @param store - a custom {@link Store} implementation (defaults to {@link MemoryCookieStore})\n   * @param options - configures how cookies are processed by the cookie jar\n   */\n  constructor(store, options) {\n    if (typeof options === 'boolean') {\n      options = {\n        rejectPublicSuffixes: options\n      };\n    }\n    this.rejectPublicSuffixes = options?.rejectPublicSuffixes ?? true;\n    this.enableLooseMode = options?.looseMode ?? false;\n    this.allowSpecialUseDomain = options?.allowSpecialUseDomain ?? true;\n    this.prefixSecurity = getNormalizedPrefixSecurity(options?.prefixSecurity ?? 'silent');\n    this.store = store ?? new memstore_1.MemoryCookieStore();\n  }\n  callSync(fn) {\n    if (!this.store.synchronous) {\n      throw new Error('CookieJar store is not synchronous; use async API instead.');\n    }\n    let syncErr = null;\n    let syncResult = undefined;\n    try {\n      fn.call(this, (error, result) => {\n        syncErr = error;\n        syncResult = result;\n      });\n    } catch (err) {\n      syncErr = err;\n    }\n    if (syncErr) throw syncErr;\n    return syncResult;\n  }\n  /**\n   * @internal No doc because this is the overload implementation\n   */\n  setCookie(cookie, url, options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = undefined;\n    }\n    const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n    const cb = promiseCallback.callback;\n    let context;\n    try {\n      if (typeof url === 'string') {\n        validators.validate(validators.isNonEmptyString(url), callback, (0, utils_1.safeToString)(options));\n      }\n      context = getCookieContext(url);\n      if (typeof url === 'function') {\n        return promiseCallback.reject(new Error('No URL was specified'));\n      }\n      if (typeof options === 'function') {\n        options = defaultSetCookieOptions;\n      }\n      validators.validate(typeof cb === 'function', cb);\n      if (!validators.isNonEmptyString(cookie) && !validators.isObject(cookie) && cookie instanceof String && cookie.length == 0) {\n        return promiseCallback.resolve(undefined);\n      }\n    } catch (err) {\n      return promiseCallback.reject(err);\n    }\n    const host = (0, canonicalDomain_1.canonicalDomain)(context.hostname) ?? null;\n    const loose = options?.loose || this.enableLooseMode;\n    let sameSiteContext = null;\n    if (options?.sameSiteContext) {\n      sameSiteContext = checkSameSiteContext(options.sameSiteContext);\n      if (!sameSiteContext) {\n        return promiseCallback.reject(new Error(SAME_SITE_CONTEXT_VAL_ERR));\n      }\n    }\n    // S5.3 step 1\n    if (typeof cookie === 'string' || cookie instanceof String) {\n      const parsedCookie = cookie_1.Cookie.parse(cookie.toString(), {\n        loose: loose\n      });\n      if (!parsedCookie) {\n        const err = new Error('Cookie failed to parse');\n        return options?.ignoreError ? promiseCallback.resolve(undefined) : promiseCallback.reject(err);\n      }\n      cookie = parsedCookie;\n    } else if (!(cookie instanceof cookie_1.Cookie)) {\n      // If you're seeing this error, and are passing in a Cookie object,\n      // it *might* be a Cookie object from another loaded version of tough-cookie.\n      const err = new Error('First argument to setCookie must be a Cookie object or string');\n      return options?.ignoreError ? promiseCallback.resolve(undefined) : promiseCallback.reject(err);\n    }\n    // S5.3 step 2\n    const now = options?.now || new Date(); // will assign later to save effort in the face of errors\n    // S5.3 step 3: NOOP; persistent-flag and expiry-time is handled by getCookie()\n    // S5.3 step 4: NOOP; domain is null by default\n    // S5.3 step 5: public suffixes\n    if (this.rejectPublicSuffixes && cookie.domain) {\n      try {\n        const cdomain = cookie.cdomain();\n        const suffix = typeof cdomain === 'string' ? (0, getPublicSuffix_1.getPublicSuffix)(cdomain, {\n          allowSpecialUseDomain: this.allowSpecialUseDomain,\n          ignoreError: options?.ignoreError\n        }) : null;\n        if (suffix == null && !constants_1.IP_V6_REGEX_OBJECT.test(cookie.domain)) {\n          // e.g. \"com\"\n          const err = new Error('Cookie has domain set to a public suffix');\n          return options?.ignoreError ? promiseCallback.resolve(undefined) : promiseCallback.reject(err);\n        }\n        // Using `any` here rather than `unknown` to avoid a type assertion, at the cost of needing\n        // to disable eslint directives. It's easier to have this one spot of technically incorrect\n        // types, rather than having to deal with _all_ callback errors being `unknown`.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      } catch (err) {\n        return options?.ignoreError ? promiseCallback.resolve(undefined) :\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        promiseCallback.reject(err);\n      }\n    }\n    // S5.3 step 6:\n    if (cookie.domain) {\n      if (!(0, domainMatch_1.domainMatch)(host ?? undefined, cookie.cdomain() ?? undefined, false)) {\n        const err = new Error(`Cookie not in this host's domain. Cookie:${cookie.cdomain() ?? 'null'} Request:${host ?? 'null'}`);\n        return options?.ignoreError ? promiseCallback.resolve(undefined) : promiseCallback.reject(err);\n      }\n      if (cookie.hostOnly == null) {\n        // don't reset if already set\n        cookie.hostOnly = false;\n      }\n    } else {\n      cookie.hostOnly = true;\n      cookie.domain = host;\n    }\n    //S5.2.4 If the attribute-value is empty or if the first character of the\n    //attribute-value is not %x2F (\"/\"):\n    //Let cookie-path be the default-path.\n    if (!cookie.path || cookie.path[0] !== '/') {\n      cookie.path = (0, defaultPath_1.defaultPath)(context.pathname);\n      cookie.pathIsDefault = true;\n    }\n    // S5.3 step 8: NOOP; secure attribute\n    // S5.3 step 9: NOOP; httpOnly attribute\n    // S5.3 step 10\n    if (options?.http === false && cookie.httpOnly) {\n      const err = new Error(\"Cookie is HttpOnly and this isn't an HTTP API\");\n      return options.ignoreError ? promiseCallback.resolve(undefined) : promiseCallback.reject(err);\n    }\n    // 6252bis-02 S5.4 Step 13 & 14:\n    if (cookie.sameSite !== 'none' && cookie.sameSite !== undefined && sameSiteContext) {\n      // \"If the cookie's \"same-site-flag\" is not \"None\", and the cookie\n      //  is being set from a context whose \"site for cookies\" is not an\n      //  exact match for request-uri's host's registered domain, then\n      //  abort these steps and ignore the newly created cookie entirely.\"\n      if (sameSiteContext === 'none') {\n        const err = new Error('Cookie is SameSite but this is a cross-origin request');\n        return options?.ignoreError ? promiseCallback.resolve(undefined) : promiseCallback.reject(err);\n      }\n    }\n    /* 6265bis-02 S5.4 Steps 15 & 16 */\n    const ignoreErrorForPrefixSecurity = this.prefixSecurity === constants_1.PrefixSecurityEnum.SILENT;\n    const prefixSecurityDisabled = this.prefixSecurity === constants_1.PrefixSecurityEnum.DISABLED;\n    /* If prefix checking is not disabled ...*/\n    if (!prefixSecurityDisabled) {\n      let errorFound = false;\n      let errorMsg;\n      /* Check secure prefix condition */\n      if (!isSecurePrefixConditionMet(cookie)) {\n        errorFound = true;\n        errorMsg = 'Cookie has __Secure prefix but Secure attribute is not set';\n      } else if (!isHostPrefixConditionMet(cookie)) {\n        /* Check host prefix condition */\n        errorFound = true;\n        errorMsg = \"Cookie has __Host prefix but either Secure or HostOnly attribute is not set or Path is not '/'\";\n      }\n      if (errorFound) {\n        return options?.ignoreError || ignoreErrorForPrefixSecurity ? promiseCallback.resolve(undefined) : promiseCallback.reject(new Error(errorMsg));\n      }\n    }\n    const store = this.store;\n    // TODO: It feels weird to be manipulating the store as a side effect of a method.\n    // We should either do it in the constructor or not at all.\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (!store.updateCookie) {\n      store.updateCookie = async function (_oldCookie, newCookie, cb) {\n        return this.putCookie(newCookie).then(() => cb?.(null), error => cb?.(error));\n      };\n    }\n    const withCookie = function withCookie(err, oldCookie) {\n      if (err) {\n        cb(err);\n        return;\n      }\n      const next = function (err) {\n        if (err) {\n          cb(err);\n        } else if (typeof cookie === 'string') {\n          cb(null, undefined);\n        } else {\n          cb(null, cookie);\n        }\n      };\n      if (oldCookie) {\n        // S5.3 step 11 - \"If the cookie store contains a cookie with the same name,\n        // domain, and path as the newly created cookie:\"\n        if (options && 'http' in options && options.http === false && oldCookie.httpOnly) {\n          // step 11.2\n          err = new Error(\"old Cookie is HttpOnly and this isn't an HTTP API\");\n          if (options.ignoreError) cb(null, undefined);else cb(err);\n          return;\n        }\n        if (cookie instanceof cookie_1.Cookie) {\n          cookie.creation = oldCookie.creation;\n          // step 11.3\n          cookie.creationIndex = oldCookie.creationIndex;\n          // preserve tie-breaker\n          cookie.lastAccessed = now;\n          // Step 11.4 (delete cookie) is implied by just setting the new one:\n          store.updateCookie(oldCookie, cookie, next); // step 12\n        }\n      } else {\n        if (cookie instanceof cookie_1.Cookie) {\n          cookie.creation = cookie.lastAccessed = now;\n          store.putCookie(cookie, next); // step 12\n        }\n      }\n    };\n    // TODO: Refactor to avoid using a callback\n    store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);\n    return promiseCallback.promise;\n  }\n  /**\n   * Synchronously attempt to set the {@link Cookie} in the {@link CookieJar}.\n   *\n   * <strong>Note:</strong> Only works if the configured {@link Store} is also synchronous.\n   *\n   * @remarks\n   * - If successfully persisted, the {@link Cookie} will have updated\n   *     {@link Cookie.creation}, {@link Cookie.lastAccessed} and {@link Cookie.hostOnly}\n   *     properties.\n   *\n   * - As per the RFC, the {@link Cookie.hostOnly} flag is set if there was no `Domain={value}`\n   *     atttribute on the cookie string. The {@link Cookie.domain} property is set to the\n   *     fully-qualified hostname of `currentUrl` in this case. Matching this cookie requires an\n   *     exact hostname match (not a {@link domainMatch} as per usual)\n   *\n   * @param cookie - The cookie object or cookie string to store. A string value will be parsed into a cookie using {@link Cookie.parse}.\n   * @param url - The domain to store the cookie with.\n   * @param options - Configuration settings to use when storing the cookie.\n   * @public\n   */\n  setCookieSync(cookie, url, options) {\n    const setCookieFn = options ? this.setCookie.bind(this, cookie, url, options) : this.setCookie.bind(this, cookie, url);\n    return this.callSync(setCookieFn);\n  }\n  /**\n   * @internal No doc because this is the overload implementation\n   */\n  getCookies(url, options, callback) {\n    // RFC6365 S5.4\n    if (typeof options === 'function') {\n      callback = options;\n      options = defaultGetCookieOptions;\n    } else if (options === undefined) {\n      options = defaultGetCookieOptions;\n    }\n    const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n    const cb = promiseCallback.callback;\n    let context;\n    try {\n      if (typeof url === 'string') {\n        validators.validate(validators.isNonEmptyString(url), cb, url);\n      }\n      context = getCookieContext(url);\n      validators.validate(validators.isObject(options), cb, (0, utils_1.safeToString)(options));\n      validators.validate(typeof cb === 'function', cb);\n    } catch (parameterError) {\n      return promiseCallback.reject(parameterError);\n    }\n    const host = (0, canonicalDomain_1.canonicalDomain)(context.hostname);\n    const path = context.pathname || '/';\n    const secure = context.protocol && (context.protocol == 'https:' || context.protocol == 'wss:');\n    let sameSiteLevel = 0;\n    if (options.sameSiteContext) {\n      const sameSiteContext = checkSameSiteContext(options.sameSiteContext);\n      if (sameSiteContext == null) {\n        return promiseCallback.reject(new Error(SAME_SITE_CONTEXT_VAL_ERR));\n      }\n      sameSiteLevel = cookie_1.Cookie.sameSiteLevel[sameSiteContext];\n      if (!sameSiteLevel) {\n        return promiseCallback.reject(new Error(SAME_SITE_CONTEXT_VAL_ERR));\n      }\n    }\n    const http = options.http ?? true;\n    const now = Date.now();\n    const expireCheck = options.expire ?? true;\n    const allPaths = options.allPaths ?? false;\n    const store = this.store;\n    function matchingCookie(c) {\n      // \"Either:\n      //   The cookie's host-only-flag is true and the canonicalized\n      //   request-host is identical to the cookie's domain.\n      // Or:\n      //   The cookie's host-only-flag is false and the canonicalized\n      //   request-host domain-matches the cookie's domain.\"\n      if (c.hostOnly) {\n        if (c.domain != host) {\n          return false;\n        }\n      } else {\n        if (!(0, domainMatch_1.domainMatch)(host ?? undefined, c.domain ?? undefined, false)) {\n          return false;\n        }\n      }\n      // \"The request-uri's path path-matches the cookie's path.\"\n      if (!allPaths && typeof c.path === 'string' && !(0, pathMatch_1.pathMatch)(path, c.path)) {\n        return false;\n      }\n      // \"If the cookie's secure-only-flag is true, then the request-uri's\n      // scheme must denote a \"secure\" protocol\"\n      if (c.secure && !secure) {\n        return false;\n      }\n      // \"If the cookie's http-only-flag is true, then exclude the cookie if the\n      // cookie-string is being generated for a \"non-HTTP\" API\"\n      if (c.httpOnly && !http) {\n        return false;\n      }\n      // RFC6265bis-02 S5.3.7\n      if (sameSiteLevel) {\n        let cookieLevel;\n        if (c.sameSite === 'lax') {\n          cookieLevel = cookie_1.Cookie.sameSiteLevel.lax;\n        } else if (c.sameSite === 'strict') {\n          cookieLevel = cookie_1.Cookie.sameSiteLevel.strict;\n        } else {\n          cookieLevel = cookie_1.Cookie.sameSiteLevel.none;\n        }\n        if (cookieLevel > sameSiteLevel) {\n          // only allow cookies at or below the request level\n          return false;\n        }\n      }\n      // deferred from S5.3\n      // non-RFC: allow retention of expired cookies by choice\n      const expiryTime = c.expiryTime();\n      if (expireCheck && expiryTime && expiryTime <= now) {\n        store.removeCookie(c.domain, c.path, c.key, () => {}); // result ignored\n        return false;\n      }\n      return true;\n    }\n    store.findCookies(host, allPaths ? null : path, this.allowSpecialUseDomain, (err, cookies) => {\n      if (err) {\n        cb(err);\n        return;\n      }\n      if (cookies == null) {\n        cb(null, []);\n        return;\n      }\n      cookies = cookies.filter(matchingCookie);\n      // sorting of S5.4 part 2\n      if ('sort' in options && options.sort !== false) {\n        cookies = cookies.sort(cookieCompare_1.cookieCompare);\n      }\n      // S5.4 part 3\n      const now = new Date();\n      for (const cookie of cookies) {\n        cookie.lastAccessed = now;\n      }\n      // TODO persist lastAccessed\n      cb(null, cookies);\n    });\n    return promiseCallback.promise;\n  }\n  /**\n   * Synchronously retrieve the list of cookies that can be sent in a Cookie header for the\n   * current URL.\n   *\n   * <strong>Note</strong>: Only works if the configured Store is also synchronous.\n   *\n   * @remarks\n   * - The array of cookies returned will be sorted according to {@link cookieCompare}.\n   *\n   * - The {@link Cookie.lastAccessed} property will be updated on all returned cookies.\n   *\n   * @param url - The domain to store the cookie with.\n   * @param options - Configuration settings to use when retrieving the cookies.\n   */\n  getCookiesSync(url, options) {\n    return this.callSync(this.getCookies.bind(this, url, options)) ?? [];\n  }\n  /**\n   * @internal No doc because this is the overload implementation\n   */\n  getCookieString(url, options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = undefined;\n    }\n    const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n    const next = function (err, cookies) {\n      if (err) {\n        promiseCallback.callback(err);\n      } else {\n        promiseCallback.callback(null, cookies?.sort(cookieCompare_1.cookieCompare).map(c => c.cookieString()).join('; '));\n      }\n    };\n    this.getCookies(url, options, next);\n    return promiseCallback.promise;\n  }\n  /**\n   * Synchronous version of `.getCookieString()`. Accepts the same options as `.getCookies()` but returns a string suitable for a\n   * `Cookie` header rather than an Array.\n   *\n   * <strong>Note</strong>: Only works if the configured Store is also synchronous.\n   *\n   * @param url - The domain to store the cookie with.\n   * @param options - Configuration settings to use when retrieving the cookies.\n   */\n  getCookieStringSync(url, options) {\n    return this.callSync(options ? this.getCookieString.bind(this, url, options) : this.getCookieString.bind(this, url)) ?? '';\n  }\n  /**\n   * @internal No doc because this is the overload implementation\n   */\n  getSetCookieStrings(url, options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = undefined;\n    }\n    const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n    const next = function (err, cookies) {\n      if (err) {\n        promiseCallback.callback(err);\n      } else {\n        promiseCallback.callback(null, cookies?.map(c => {\n          return c.toString();\n        }));\n      }\n    };\n    this.getCookies(url, options, next);\n    return promiseCallback.promise;\n  }\n  /**\n   * Synchronous version of `.getSetCookieStrings()`. Returns an array of strings suitable for `Set-Cookie` headers.\n   * Accepts the same options as `.getCookies()`.\n   *\n   * <strong>Note</strong>: Only works if the configured Store is also synchronous.\n   *\n   * @param url - The domain to store the cookie with.\n   * @param options - Configuration settings to use when retrieving the cookies.\n   */\n  getSetCookieStringsSync(url, options = {}) {\n    return this.callSync(this.getSetCookieStrings.bind(this, url, options)) ?? [];\n  }\n  /**\n   * @internal No doc because this is the overload implementation\n   */\n  serialize(callback) {\n    const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n    let type = this.store.constructor.name;\n    if (validators.isObject(type)) {\n      type = null;\n    }\n    // update README.md \"Serialization Format\" if you change this, please!\n    const serialized = {\n      // The version of tough-cookie that serialized this jar. Generally a good\n      // practice since future versions can make data import decisions based on\n      // known past behavior. When/if this matters, use `semver`.\n      version: `tough-cookie@${version_1.version}`,\n      // add the store type, to make humans happy:\n      storeType: type,\n      // CookieJar configuration:\n      rejectPublicSuffixes: this.rejectPublicSuffixes,\n      enableLooseMode: this.enableLooseMode,\n      allowSpecialUseDomain: this.allowSpecialUseDomain,\n      prefixSecurity: getNormalizedPrefixSecurity(this.prefixSecurity),\n      // this gets filled from getAllCookies:\n      cookies: []\n    };\n    if (typeof this.store.getAllCookies !== 'function') {\n      return promiseCallback.reject(new Error('store does not support getAllCookies and cannot be serialized'));\n    }\n    this.store.getAllCookies((err, cookies) => {\n      if (err) {\n        promiseCallback.callback(err);\n        return;\n      }\n      if (cookies == null) {\n        promiseCallback.callback(null, serialized);\n        return;\n      }\n      serialized.cookies = cookies.map(cookie => {\n        // convert to serialized 'raw' cookies\n        const serializedCookie = cookie.toJSON();\n        // Remove the index so new ones get assigned during deserialization\n        delete serializedCookie.creationIndex;\n        return serializedCookie;\n      });\n      promiseCallback.callback(null, serialized);\n    });\n    return promiseCallback.promise;\n  }\n  /**\n   * Serialize the CookieJar if the underlying store supports `.getAllCookies`.\n   *\n   * <strong>Note</strong>: Only works if the configured Store is also synchronous.\n   */\n  serializeSync() {\n    return this.callSync(callback => {\n      this.serialize(callback);\n    });\n  }\n  /**\n   * Alias of {@link CookieJar.serializeSync}. Allows the cookie to be serialized\n   * with `JSON.stringify(cookieJar)`.\n   */\n  toJSON() {\n    return this.serializeSync();\n  }\n  /**\n   * Use the class method CookieJar.deserialize instead of calling this directly\n   * @internal\n   */\n  _importCookies(serialized, callback) {\n    let cookies = undefined;\n    if (serialized && typeof serialized === 'object' && (0, utils_1.inOperator)('cookies', serialized) && Array.isArray(serialized.cookies)) {\n      cookies = serialized.cookies;\n    }\n    if (!cookies) {\n      callback(new Error('serialized jar has no cookies array'), undefined);\n      return;\n    }\n    cookies = cookies.slice(); // do not modify the original\n    const putNext = err => {\n      if (err) {\n        callback(err, undefined);\n        return;\n      }\n      if (Array.isArray(cookies)) {\n        if (!cookies.length) {\n          callback(err, this);\n          return;\n        }\n        let cookie;\n        try {\n          cookie = cookie_1.Cookie.fromJSON(cookies.shift());\n        } catch (e) {\n          callback(e instanceof Error ? e : new Error(), undefined);\n          return;\n        }\n        if (cookie === undefined) {\n          putNext(null); // skip this cookie\n          return;\n        }\n        this.store.putCookie(cookie, putNext);\n      }\n    };\n    putNext(null);\n  }\n  /**\n   * @internal\n   */\n  _importCookiesSync(serialized) {\n    this.callSync(this._importCookies.bind(this, serialized));\n  }\n  /**\n   * @internal No doc because this is the overload implementation\n   */\n  clone(newStore, callback) {\n    if (typeof newStore === 'function') {\n      callback = newStore;\n      newStore = undefined;\n    }\n    const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n    const cb = promiseCallback.callback;\n    this.serialize((err, serialized) => {\n      if (err) {\n        return promiseCallback.reject(err);\n      }\n      return CookieJar.deserialize(serialized ?? '', newStore, cb);\n    });\n    return promiseCallback.promise;\n  }\n  /**\n   * @internal\n   */\n  _cloneSync(newStore) {\n    const cloneFn = newStore && typeof newStore !== 'function' ? this.clone.bind(this, newStore) : this.clone.bind(this);\n    return this.callSync(callback => {\n      cloneFn(callback);\n    });\n  }\n  /**\n   * Produces a deep clone of this CookieJar. Modifications to the original do\n   * not affect the clone, and vice versa.\n   *\n   * <strong>Note</strong>: Only works if both the configured Store and destination\n   * Store are synchronous.\n   *\n   * @remarks\n   * - When no {@link Store} is provided, a new {@link MemoryCookieStore} will be used.\n   *\n   * - Transferring between store types is supported so long as the source\n   *     implements `.getAllCookies()` and the destination implements `.putCookie()`.\n   *\n   * @param newStore - The target {@link Store} to clone cookies into.\n   */\n  cloneSync(newStore) {\n    if (!newStore) {\n      return this._cloneSync();\n    }\n    if (!newStore.synchronous) {\n      throw new Error('CookieJar clone destination store is not synchronous; use async API instead.');\n    }\n    return this._cloneSync(newStore);\n  }\n  /**\n   * @internal No doc because this is the overload implementation\n   */\n  removeAllCookies(callback) {\n    const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n    const cb = promiseCallback.callback;\n    const store = this.store;\n    // Check that the store implements its own removeAllCookies(). The default\n    // implementation in Store will immediately call the callback with a \"not\n    // implemented\" Error.\n    if (typeof store.removeAllCookies === 'function' && store.removeAllCookies !== store_1.Store.prototype.removeAllCookies) {\n      // `Callback<undefined>` and `ErrorCallback` are *technically* incompatible, but for the\n      // standard implementation `cb = (err, result) => {}`, they're essentially the same.\n      store.removeAllCookies(cb);\n      return promiseCallback.promise;\n    }\n    store.getAllCookies((err, cookies) => {\n      if (err) {\n        cb(err);\n        return;\n      }\n      if (!cookies) {\n        cookies = [];\n      }\n      if (cookies.length === 0) {\n        cb(null, undefined);\n        return;\n      }\n      let completedCount = 0;\n      const removeErrors = [];\n      // TODO: Refactor to avoid using callback\n      const removeCookieCb = function removeCookieCb(removeErr) {\n        if (removeErr) {\n          removeErrors.push(removeErr);\n        }\n        completedCount++;\n        if (completedCount === cookies.length) {\n          if (removeErrors[0]) cb(removeErrors[0]);else cb(null, undefined);\n          return;\n        }\n      };\n      cookies.forEach(cookie => {\n        store.removeCookie(cookie.domain, cookie.path, cookie.key, removeCookieCb);\n      });\n    });\n    return promiseCallback.promise;\n  }\n  /**\n   * Removes all cookies from the CookieJar.\n   *\n   * <strong>Note</strong>: Only works if the configured Store is also synchronous.\n   *\n   * @remarks\n   * - This is a new backwards-compatible feature of tough-cookie version 2.5,\n   *     so not all Stores will implement it efficiently. For Stores that do not\n   *     implement `removeAllCookies`, the fallback is to call `removeCookie` after\n   *     `getAllCookies`.\n   *\n   * - If `getAllCookies` fails or isn't implemented in the Store, an error is returned.\n   *\n   * - If one or more of the `removeCookie` calls fail, only the first error is returned.\n   */\n  removeAllCookiesSync() {\n    this.callSync(callback => {\n      // `Callback<undefined>` and `ErrorCallback` are *technically* incompatible, but for the\n      // standard implementation `cb = (err, result) => {}`, they're essentially the same.\n      this.removeAllCookies(callback);\n    });\n  }\n  /**\n   * @internal No doc because this is the overload implementation\n   */\n  static deserialize(strOrObj, store, callback) {\n    if (typeof store === 'function') {\n      callback = store;\n      store = undefined;\n    }\n    const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n    let serialized;\n    if (typeof strOrObj === 'string') {\n      try {\n        serialized = JSON.parse(strOrObj);\n      } catch (e) {\n        return promiseCallback.reject(e instanceof Error ? e : new Error());\n      }\n    } else {\n      serialized = strOrObj;\n    }\n    const readSerializedProperty = property => {\n      return serialized && typeof serialized === 'object' && (0, utils_1.inOperator)(property, serialized) ? serialized[property] : undefined;\n    };\n    const readSerializedBoolean = property => {\n      const value = readSerializedProperty(property);\n      return typeof value === 'boolean' ? value : undefined;\n    };\n    const readSerializedString = property => {\n      const value = readSerializedProperty(property);\n      return typeof value === 'string' ? value : undefined;\n    };\n    const jar = new CookieJar(store, {\n      rejectPublicSuffixes: readSerializedBoolean('rejectPublicSuffixes'),\n      looseMode: readSerializedBoolean('enableLooseMode'),\n      allowSpecialUseDomain: readSerializedBoolean('allowSpecialUseDomain'),\n      prefixSecurity: getNormalizedPrefixSecurity(readSerializedString('prefixSecurity') ?? 'silent')\n    });\n    jar._importCookies(serialized, err => {\n      if (err) {\n        promiseCallback.callback(err);\n        return;\n      }\n      promiseCallback.callback(null, jar);\n    });\n    return promiseCallback.promise;\n  }\n  /**\n   * A new CookieJar is created and the serialized {@link Cookie} values are added to\n   * the underlying store. Each {@link Cookie} is added via `store.putCookie(...)` in\n   * the order in which they appear in the serialization.\n   *\n   * <strong>Note</strong>: Only works if the configured Store is also synchronous.\n   *\n   * @remarks\n   * - When no {@link Store} is provided, a new {@link MemoryCookieStore} will be used.\n   *\n   * - As a convenience, if `strOrObj` is a string, it is passed through `JSON.parse` first.\n   *\n   * @param strOrObj - A JSON string or object representing the deserialized cookies.\n   * @param store - The underlying store to persist the deserialized cookies into.\n   */\n  static deserializeSync(strOrObj, store) {\n    const serialized = typeof strOrObj === 'string' ? JSON.parse(strOrObj) : strOrObj;\n    const readSerializedProperty = property => {\n      return serialized && typeof serialized === 'object' && (0, utils_1.inOperator)(property, serialized) ? serialized[property] : undefined;\n    };\n    const readSerializedBoolean = property => {\n      const value = readSerializedProperty(property);\n      return typeof value === 'boolean' ? value : undefined;\n    };\n    const readSerializedString = property => {\n      const value = readSerializedProperty(property);\n      return typeof value === 'string' ? value : undefined;\n    };\n    const jar = new CookieJar(store, {\n      rejectPublicSuffixes: readSerializedBoolean('rejectPublicSuffixes'),\n      looseMode: readSerializedBoolean('enableLooseMode'),\n      allowSpecialUseDomain: readSerializedBoolean('allowSpecialUseDomain'),\n      prefixSecurity: getNormalizedPrefixSecurity(readSerializedString('prefixSecurity') ?? 'silent')\n    });\n    // catch this mistake early:\n    if (!jar.store.synchronous) {\n      throw new Error('CookieJar store is not synchronous; use async API instead.');\n    }\n    jar._importCookiesSync(serialized);\n    return jar;\n  }\n  /**\n   * Alias of {@link CookieJar.deserializeSync}.\n   *\n   * @remarks\n   * - When no {@link Store} is provided, a new {@link MemoryCookieStore} will be used.\n   *\n   * - As a convenience, if `strOrObj` is a string, it is passed through `JSON.parse` first.\n   *\n   * @param jsonString - A JSON string or object representing the deserialized cookies.\n   * @param store - The underlying store to persist the deserialized cookies into.\n   */\n  static fromJSON(jsonString, store) {\n    return CookieJar.deserializeSync(jsonString, store);\n  }\n}\nexports.CookieJar = CookieJar;","map":{"version":3,"names":["require","__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","exports","CookieJar","getPublicSuffix_1","validators","validators_1","store_1","memstore_1","pathMatch_1","cookie_1","utils_1","canonicalDomain_1","constants_1","defaultPath_1","domainMatch_1","cookieCompare_1","version_1","defaultSetCookieOptions","loose","sameSiteContext","ignoreError","http","defaultGetCookieOptions","expire","allPaths","sort","SAME_SITE_CONTEXT_VAL_ERR","getCookieContext","url","hostname","pathname","protocol","URL","decodeURI","ParameterError","checkSameSiteContext","context","String","toLowerCase","isSecurePrefixConditionMet","cookie","startsWithSecurePrefix","key","startsWith","secure","isHostPrefixConditionMet","startsWithHostPrefix","Boolean","hostOnly","path","getNormalizedPrefixSecurity","prefixSecurity","normalizedPrefixSecurity","PrefixSecurityEnum","STRICT","SILENT","DISABLED","constructor","store","options","rejectPublicSuffixes","enableLooseMode","looseMode","allowSpecialUseDomain","MemoryCookieStore","callSync","fn","synchronous","Error","syncErr","syncResult","error","err","setCookie","callback","promiseCallback","createPromiseCallback","cb","validate","isNonEmptyString","safeToString","reject","isObject","length","resolve","host","canonicalDomain","parsedCookie","Cookie","parse","toString","now","Date","domain","cdomain","suffix","getPublicSuffix","IP_V6_REGEX_OBJECT","test","domainMatch","defaultPath","pathIsDefault","httpOnly","sameSite","ignoreErrorForPrefixSecurity","prefixSecurityDisabled","errorFound","errorMsg","updateCookie","_oldCookie","newCookie","putCookie","then","withCookie","oldCookie","next","creation","creationIndex","lastAccessed","findCookie","promise","setCookieSync","setCookieFn","bind","getCookies","parameterError","sameSiteLevel","expireCheck","matchingCookie","c","pathMatch","cookieLevel","lax","strict","none","expiryTime","removeCookie","findCookies","cookies","filter","cookieCompare","getCookiesSync","getCookieString","map","cookieString","join","getCookieStringSync","getSetCookieStrings","getSetCookieStringsSync","serialize","type","name","serialized","version","storeType","getAllCookies","serializedCookie","toJSON","serializeSync","_importCookies","inOperator","Array","isArray","slice","putNext","fromJSON","shift","e","_importCookiesSync","clone","newStore","deserialize","_cloneSync","cloneFn","cloneSync","removeAllCookies","Store","completedCount","removeErrors","removeCookieCb","removeErr","push","forEach","removeAllCookiesSync","strOrObj","JSON","readSerializedProperty","property","readSerializedBoolean","readSerializedString","jar","deserializeSync","jsonString"],"sources":["/Users/feyraf/Desktop/projets/Roma/invest/node_modules/tough-cookie/dist/cookie/cookieJar.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CookieJar = void 0;\nconst getPublicSuffix_1 = require(\"../getPublicSuffix\");\nconst validators = __importStar(require(\"../validators\"));\nconst validators_1 = require(\"../validators\");\nconst store_1 = require(\"../store\");\nconst memstore_1 = require(\"../memstore\");\nconst pathMatch_1 = require(\"../pathMatch\");\nconst cookie_1 = require(\"./cookie\");\nconst utils_1 = require(\"../utils\");\nconst canonicalDomain_1 = require(\"./canonicalDomain\");\nconst constants_1 = require(\"./constants\");\nconst defaultPath_1 = require(\"./defaultPath\");\nconst domainMatch_1 = require(\"./domainMatch\");\nconst cookieCompare_1 = require(\"./cookieCompare\");\nconst version_1 = require(\"../version\");\nconst defaultSetCookieOptions = {\n    loose: false,\n    sameSiteContext: undefined,\n    ignoreError: false,\n    http: true,\n};\nconst defaultGetCookieOptions = {\n    http: true,\n    expire: true,\n    allPaths: false,\n    sameSiteContext: undefined,\n    sort: undefined,\n};\nconst SAME_SITE_CONTEXT_VAL_ERR = 'Invalid sameSiteContext option for getCookies(); expected one of \"strict\", \"lax\", or \"none\"';\nfunction getCookieContext(url) {\n    if (url &&\n        typeof url === 'object' &&\n        'hostname' in url &&\n        typeof url.hostname === 'string' &&\n        'pathname' in url &&\n        typeof url.pathname === 'string' &&\n        'protocol' in url &&\n        typeof url.protocol === 'string') {\n        return {\n            hostname: url.hostname,\n            pathname: url.pathname,\n            protocol: url.protocol,\n        };\n    }\n    else if (typeof url === 'string') {\n        try {\n            return new URL(decodeURI(url));\n        }\n        catch {\n            return new URL(url);\n        }\n    }\n    else {\n        throw new validators_1.ParameterError('`url` argument is not a string or URL.');\n    }\n}\nfunction checkSameSiteContext(value) {\n    const context = String(value).toLowerCase();\n    if (context === 'none' || context === 'lax' || context === 'strict') {\n        return context;\n    }\n    else {\n        return undefined;\n    }\n}\n/**\n *  If the cookie-name begins with a case-sensitive match for the\n *  string \"__Secure-\", abort these steps and ignore the cookie\n *  entirely unless the cookie's secure-only-flag is true.\n * @param cookie\n * @returns boolean\n */\nfunction isSecurePrefixConditionMet(cookie) {\n    const startsWithSecurePrefix = typeof cookie.key === 'string' && cookie.key.startsWith('__Secure-');\n    return !startsWithSecurePrefix || cookie.secure;\n}\n/**\n *  If the cookie-name begins with a case-sensitive match for the\n *  string \"__Host-\", abort these steps and ignore the cookie\n *  entirely unless the cookie meets all the following criteria:\n *    1.  The cookie's secure-only-flag is true.\n *    2.  The cookie's host-only-flag is true.\n *    3.  The cookie-attribute-list contains an attribute with an\n *        attribute-name of \"Path\", and the cookie's path is \"/\".\n * @param cookie\n * @returns boolean\n */\nfunction isHostPrefixConditionMet(cookie) {\n    const startsWithHostPrefix = typeof cookie.key === 'string' && cookie.key.startsWith('__Host-');\n    return (!startsWithHostPrefix ||\n        Boolean(cookie.secure &&\n            cookie.hostOnly &&\n            cookie.path != null &&\n            cookie.path === '/'));\n}\nfunction getNormalizedPrefixSecurity(prefixSecurity) {\n    const normalizedPrefixSecurity = prefixSecurity.toLowerCase();\n    /* The three supported options */\n    switch (normalizedPrefixSecurity) {\n        case constants_1.PrefixSecurityEnum.STRICT:\n        case constants_1.PrefixSecurityEnum.SILENT:\n        case constants_1.PrefixSecurityEnum.DISABLED:\n            return normalizedPrefixSecurity;\n        default:\n            return constants_1.PrefixSecurityEnum.SILENT;\n    }\n}\n/**\n * A CookieJar is for storage and retrieval of {@link Cookie} objects as defined in\n * {@link https://www.rfc-editor.org/rfc/rfc6265.html#section-5.3 | RFC6265 - Section 5.3}.\n *\n * It also supports a pluggable persistence layer via {@link Store}.\n * @public\n */\nclass CookieJar {\n    /**\n     * Creates a new `CookieJar` instance.\n     *\n     * @remarks\n     * - If a custom store is not passed to the constructor, an in-memory store ({@link MemoryCookieStore} will be created and used.\n     * - If a boolean value is passed as the `options` parameter, this is equivalent to passing `{ rejectPublicSuffixes: <value> }`\n     *\n     * @param store - a custom {@link Store} implementation (defaults to {@link MemoryCookieStore})\n     * @param options - configures how cookies are processed by the cookie jar\n     */\n    constructor(store, options) {\n        if (typeof options === 'boolean') {\n            options = { rejectPublicSuffixes: options };\n        }\n        this.rejectPublicSuffixes = options?.rejectPublicSuffixes ?? true;\n        this.enableLooseMode = options?.looseMode ?? false;\n        this.allowSpecialUseDomain = options?.allowSpecialUseDomain ?? true;\n        this.prefixSecurity = getNormalizedPrefixSecurity(options?.prefixSecurity ?? 'silent');\n        this.store = store ?? new memstore_1.MemoryCookieStore();\n    }\n    callSync(fn) {\n        if (!this.store.synchronous) {\n            throw new Error('CookieJar store is not synchronous; use async API instead.');\n        }\n        let syncErr = null;\n        let syncResult = undefined;\n        try {\n            fn.call(this, (error, result) => {\n                syncErr = error;\n                syncResult = result;\n            });\n        }\n        catch (err) {\n            syncErr = err;\n        }\n        if (syncErr)\n            throw syncErr;\n        return syncResult;\n    }\n    /**\n     * @internal No doc because this is the overload implementation\n     */\n    setCookie(cookie, url, options, callback) {\n        if (typeof options === 'function') {\n            callback = options;\n            options = undefined;\n        }\n        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n        const cb = promiseCallback.callback;\n        let context;\n        try {\n            if (typeof url === 'string') {\n                validators.validate(validators.isNonEmptyString(url), callback, (0, utils_1.safeToString)(options));\n            }\n            context = getCookieContext(url);\n            if (typeof url === 'function') {\n                return promiseCallback.reject(new Error('No URL was specified'));\n            }\n            if (typeof options === 'function') {\n                options = defaultSetCookieOptions;\n            }\n            validators.validate(typeof cb === 'function', cb);\n            if (!validators.isNonEmptyString(cookie) &&\n                !validators.isObject(cookie) &&\n                cookie instanceof String &&\n                cookie.length == 0) {\n                return promiseCallback.resolve(undefined);\n            }\n        }\n        catch (err) {\n            return promiseCallback.reject(err);\n        }\n        const host = (0, canonicalDomain_1.canonicalDomain)(context.hostname) ?? null;\n        const loose = options?.loose || this.enableLooseMode;\n        let sameSiteContext = null;\n        if (options?.sameSiteContext) {\n            sameSiteContext = checkSameSiteContext(options.sameSiteContext);\n            if (!sameSiteContext) {\n                return promiseCallback.reject(new Error(SAME_SITE_CONTEXT_VAL_ERR));\n            }\n        }\n        // S5.3 step 1\n        if (typeof cookie === 'string' || cookie instanceof String) {\n            const parsedCookie = cookie_1.Cookie.parse(cookie.toString(), { loose: loose });\n            if (!parsedCookie) {\n                const err = new Error('Cookie failed to parse');\n                return options?.ignoreError\n                    ? promiseCallback.resolve(undefined)\n                    : promiseCallback.reject(err);\n            }\n            cookie = parsedCookie;\n        }\n        else if (!(cookie instanceof cookie_1.Cookie)) {\n            // If you're seeing this error, and are passing in a Cookie object,\n            // it *might* be a Cookie object from another loaded version of tough-cookie.\n            const err = new Error('First argument to setCookie must be a Cookie object or string');\n            return options?.ignoreError\n                ? promiseCallback.resolve(undefined)\n                : promiseCallback.reject(err);\n        }\n        // S5.3 step 2\n        const now = options?.now || new Date(); // will assign later to save effort in the face of errors\n        // S5.3 step 3: NOOP; persistent-flag and expiry-time is handled by getCookie()\n        // S5.3 step 4: NOOP; domain is null by default\n        // S5.3 step 5: public suffixes\n        if (this.rejectPublicSuffixes && cookie.domain) {\n            try {\n                const cdomain = cookie.cdomain();\n                const suffix = typeof cdomain === 'string'\n                    ? (0, getPublicSuffix_1.getPublicSuffix)(cdomain, {\n                        allowSpecialUseDomain: this.allowSpecialUseDomain,\n                        ignoreError: options?.ignoreError,\n                    })\n                    : null;\n                if (suffix == null && !constants_1.IP_V6_REGEX_OBJECT.test(cookie.domain)) {\n                    // e.g. \"com\"\n                    const err = new Error('Cookie has domain set to a public suffix');\n                    return options?.ignoreError\n                        ? promiseCallback.resolve(undefined)\n                        : promiseCallback.reject(err);\n                }\n                // Using `any` here rather than `unknown` to avoid a type assertion, at the cost of needing\n                // to disable eslint directives. It's easier to have this one spot of technically incorrect\n                // types, rather than having to deal with _all_ callback errors being `unknown`.\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            }\n            catch (err) {\n                return options?.ignoreError\n                    ? promiseCallback.resolve(undefined)\n                    : // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                        promiseCallback.reject(err);\n            }\n        }\n        // S5.3 step 6:\n        if (cookie.domain) {\n            if (!(0, domainMatch_1.domainMatch)(host ?? undefined, cookie.cdomain() ?? undefined, false)) {\n                const err = new Error(`Cookie not in this host's domain. Cookie:${cookie.cdomain() ?? 'null'} Request:${host ?? 'null'}`);\n                return options?.ignoreError\n                    ? promiseCallback.resolve(undefined)\n                    : promiseCallback.reject(err);\n            }\n            if (cookie.hostOnly == null) {\n                // don't reset if already set\n                cookie.hostOnly = false;\n            }\n        }\n        else {\n            cookie.hostOnly = true;\n            cookie.domain = host;\n        }\n        //S5.2.4 If the attribute-value is empty or if the first character of the\n        //attribute-value is not %x2F (\"/\"):\n        //Let cookie-path be the default-path.\n        if (!cookie.path || cookie.path[0] !== '/') {\n            cookie.path = (0, defaultPath_1.defaultPath)(context.pathname);\n            cookie.pathIsDefault = true;\n        }\n        // S5.3 step 8: NOOP; secure attribute\n        // S5.3 step 9: NOOP; httpOnly attribute\n        // S5.3 step 10\n        if (options?.http === false && cookie.httpOnly) {\n            const err = new Error(\"Cookie is HttpOnly and this isn't an HTTP API\");\n            return options.ignoreError\n                ? promiseCallback.resolve(undefined)\n                : promiseCallback.reject(err);\n        }\n        // 6252bis-02 S5.4 Step 13 & 14:\n        if (cookie.sameSite !== 'none' &&\n            cookie.sameSite !== undefined &&\n            sameSiteContext) {\n            // \"If the cookie's \"same-site-flag\" is not \"None\", and the cookie\n            //  is being set from a context whose \"site for cookies\" is not an\n            //  exact match for request-uri's host's registered domain, then\n            //  abort these steps and ignore the newly created cookie entirely.\"\n            if (sameSiteContext === 'none') {\n                const err = new Error('Cookie is SameSite but this is a cross-origin request');\n                return options?.ignoreError\n                    ? promiseCallback.resolve(undefined)\n                    : promiseCallback.reject(err);\n            }\n        }\n        /* 6265bis-02 S5.4 Steps 15 & 16 */\n        const ignoreErrorForPrefixSecurity = this.prefixSecurity === constants_1.PrefixSecurityEnum.SILENT;\n        const prefixSecurityDisabled = this.prefixSecurity === constants_1.PrefixSecurityEnum.DISABLED;\n        /* If prefix checking is not disabled ...*/\n        if (!prefixSecurityDisabled) {\n            let errorFound = false;\n            let errorMsg;\n            /* Check secure prefix condition */\n            if (!isSecurePrefixConditionMet(cookie)) {\n                errorFound = true;\n                errorMsg = 'Cookie has __Secure prefix but Secure attribute is not set';\n            }\n            else if (!isHostPrefixConditionMet(cookie)) {\n                /* Check host prefix condition */\n                errorFound = true;\n                errorMsg =\n                    \"Cookie has __Host prefix but either Secure or HostOnly attribute is not set or Path is not '/'\";\n            }\n            if (errorFound) {\n                return options?.ignoreError || ignoreErrorForPrefixSecurity\n                    ? promiseCallback.resolve(undefined)\n                    : promiseCallback.reject(new Error(errorMsg));\n            }\n        }\n        const store = this.store;\n        // TODO: It feels weird to be manipulating the store as a side effect of a method.\n        // We should either do it in the constructor or not at all.\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (!store.updateCookie) {\n            store.updateCookie = async function (_oldCookie, newCookie, cb) {\n                return this.putCookie(newCookie).then(() => cb?.(null), (error) => cb?.(error));\n            };\n        }\n        const withCookie = function withCookie(err, oldCookie) {\n            if (err) {\n                cb(err);\n                return;\n            }\n            const next = function (err) {\n                if (err) {\n                    cb(err);\n                }\n                else if (typeof cookie === 'string') {\n                    cb(null, undefined);\n                }\n                else {\n                    cb(null, cookie);\n                }\n            };\n            if (oldCookie) {\n                // S5.3 step 11 - \"If the cookie store contains a cookie with the same name,\n                // domain, and path as the newly created cookie:\"\n                if (options &&\n                    'http' in options &&\n                    options.http === false &&\n                    oldCookie.httpOnly) {\n                    // step 11.2\n                    err = new Error(\"old Cookie is HttpOnly and this isn't an HTTP API\");\n                    if (options.ignoreError)\n                        cb(null, undefined);\n                    else\n                        cb(err);\n                    return;\n                }\n                if (cookie instanceof cookie_1.Cookie) {\n                    cookie.creation = oldCookie.creation;\n                    // step 11.3\n                    cookie.creationIndex = oldCookie.creationIndex;\n                    // preserve tie-breaker\n                    cookie.lastAccessed = now;\n                    // Step 11.4 (delete cookie) is implied by just setting the new one:\n                    store.updateCookie(oldCookie, cookie, next); // step 12\n                }\n            }\n            else {\n                if (cookie instanceof cookie_1.Cookie) {\n                    cookie.creation = cookie.lastAccessed = now;\n                    store.putCookie(cookie, next); // step 12\n                }\n            }\n        };\n        // TODO: Refactor to avoid using a callback\n        store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);\n        return promiseCallback.promise;\n    }\n    /**\n     * Synchronously attempt to set the {@link Cookie} in the {@link CookieJar}.\n     *\n     * <strong>Note:</strong> Only works if the configured {@link Store} is also synchronous.\n     *\n     * @remarks\n     * - If successfully persisted, the {@link Cookie} will have updated\n     *     {@link Cookie.creation}, {@link Cookie.lastAccessed} and {@link Cookie.hostOnly}\n     *     properties.\n     *\n     * - As per the RFC, the {@link Cookie.hostOnly} flag is set if there was no `Domain={value}`\n     *     atttribute on the cookie string. The {@link Cookie.domain} property is set to the\n     *     fully-qualified hostname of `currentUrl` in this case. Matching this cookie requires an\n     *     exact hostname match (not a {@link domainMatch} as per usual)\n     *\n     * @param cookie - The cookie object or cookie string to store. A string value will be parsed into a cookie using {@link Cookie.parse}.\n     * @param url - The domain to store the cookie with.\n     * @param options - Configuration settings to use when storing the cookie.\n     * @public\n     */\n    setCookieSync(cookie, url, options) {\n        const setCookieFn = options\n            ? this.setCookie.bind(this, cookie, url, options)\n            : this.setCookie.bind(this, cookie, url);\n        return this.callSync(setCookieFn);\n    }\n    /**\n     * @internal No doc because this is the overload implementation\n     */\n    getCookies(url, options, callback) {\n        // RFC6365 S5.4\n        if (typeof options === 'function') {\n            callback = options;\n            options = defaultGetCookieOptions;\n        }\n        else if (options === undefined) {\n            options = defaultGetCookieOptions;\n        }\n        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n        const cb = promiseCallback.callback;\n        let context;\n        try {\n            if (typeof url === 'string') {\n                validators.validate(validators.isNonEmptyString(url), cb, url);\n            }\n            context = getCookieContext(url);\n            validators.validate(validators.isObject(options), cb, (0, utils_1.safeToString)(options));\n            validators.validate(typeof cb === 'function', cb);\n        }\n        catch (parameterError) {\n            return promiseCallback.reject(parameterError);\n        }\n        const host = (0, canonicalDomain_1.canonicalDomain)(context.hostname);\n        const path = context.pathname || '/';\n        const secure = context.protocol &&\n            (context.protocol == 'https:' || context.protocol == 'wss:');\n        let sameSiteLevel = 0;\n        if (options.sameSiteContext) {\n            const sameSiteContext = checkSameSiteContext(options.sameSiteContext);\n            if (sameSiteContext == null) {\n                return promiseCallback.reject(new Error(SAME_SITE_CONTEXT_VAL_ERR));\n            }\n            sameSiteLevel = cookie_1.Cookie.sameSiteLevel[sameSiteContext];\n            if (!sameSiteLevel) {\n                return promiseCallback.reject(new Error(SAME_SITE_CONTEXT_VAL_ERR));\n            }\n        }\n        const http = options.http ?? true;\n        const now = Date.now();\n        const expireCheck = options.expire ?? true;\n        const allPaths = options.allPaths ?? false;\n        const store = this.store;\n        function matchingCookie(c) {\n            // \"Either:\n            //   The cookie's host-only-flag is true and the canonicalized\n            //   request-host is identical to the cookie's domain.\n            // Or:\n            //   The cookie's host-only-flag is false and the canonicalized\n            //   request-host domain-matches the cookie's domain.\"\n            if (c.hostOnly) {\n                if (c.domain != host) {\n                    return false;\n                }\n            }\n            else {\n                if (!(0, domainMatch_1.domainMatch)(host ?? undefined, c.domain ?? undefined, false)) {\n                    return false;\n                }\n            }\n            // \"The request-uri's path path-matches the cookie's path.\"\n            if (!allPaths && typeof c.path === 'string' && !(0, pathMatch_1.pathMatch)(path, c.path)) {\n                return false;\n            }\n            // \"If the cookie's secure-only-flag is true, then the request-uri's\n            // scheme must denote a \"secure\" protocol\"\n            if (c.secure && !secure) {\n                return false;\n            }\n            // \"If the cookie's http-only-flag is true, then exclude the cookie if the\n            // cookie-string is being generated for a \"non-HTTP\" API\"\n            if (c.httpOnly && !http) {\n                return false;\n            }\n            // RFC6265bis-02 S5.3.7\n            if (sameSiteLevel) {\n                let cookieLevel;\n                if (c.sameSite === 'lax') {\n                    cookieLevel = cookie_1.Cookie.sameSiteLevel.lax;\n                }\n                else if (c.sameSite === 'strict') {\n                    cookieLevel = cookie_1.Cookie.sameSiteLevel.strict;\n                }\n                else {\n                    cookieLevel = cookie_1.Cookie.sameSiteLevel.none;\n                }\n                if (cookieLevel > sameSiteLevel) {\n                    // only allow cookies at or below the request level\n                    return false;\n                }\n            }\n            // deferred from S5.3\n            // non-RFC: allow retention of expired cookies by choice\n            const expiryTime = c.expiryTime();\n            if (expireCheck && expiryTime && expiryTime <= now) {\n                store.removeCookie(c.domain, c.path, c.key, () => { }); // result ignored\n                return false;\n            }\n            return true;\n        }\n        store.findCookies(host, allPaths ? null : path, this.allowSpecialUseDomain, (err, cookies) => {\n            if (err) {\n                cb(err);\n                return;\n            }\n            if (cookies == null) {\n                cb(null, []);\n                return;\n            }\n            cookies = cookies.filter(matchingCookie);\n            // sorting of S5.4 part 2\n            if ('sort' in options && options.sort !== false) {\n                cookies = cookies.sort(cookieCompare_1.cookieCompare);\n            }\n            // S5.4 part 3\n            const now = new Date();\n            for (const cookie of cookies) {\n                cookie.lastAccessed = now;\n            }\n            // TODO persist lastAccessed\n            cb(null, cookies);\n        });\n        return promiseCallback.promise;\n    }\n    /**\n     * Synchronously retrieve the list of cookies that can be sent in a Cookie header for the\n     * current URL.\n     *\n     * <strong>Note</strong>: Only works if the configured Store is also synchronous.\n     *\n     * @remarks\n     * - The array of cookies returned will be sorted according to {@link cookieCompare}.\n     *\n     * - The {@link Cookie.lastAccessed} property will be updated on all returned cookies.\n     *\n     * @param url - The domain to store the cookie with.\n     * @param options - Configuration settings to use when retrieving the cookies.\n     */\n    getCookiesSync(url, options) {\n        return this.callSync(this.getCookies.bind(this, url, options)) ?? [];\n    }\n    /**\n     * @internal No doc because this is the overload implementation\n     */\n    getCookieString(url, options, callback) {\n        if (typeof options === 'function') {\n            callback = options;\n            options = undefined;\n        }\n        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n        const next = function (err, cookies) {\n            if (err) {\n                promiseCallback.callback(err);\n            }\n            else {\n                promiseCallback.callback(null, cookies\n                    ?.sort(cookieCompare_1.cookieCompare)\n                    .map((c) => c.cookieString())\n                    .join('; '));\n            }\n        };\n        this.getCookies(url, options, next);\n        return promiseCallback.promise;\n    }\n    /**\n     * Synchronous version of `.getCookieString()`. Accepts the same options as `.getCookies()` but returns a string suitable for a\n     * `Cookie` header rather than an Array.\n     *\n     * <strong>Note</strong>: Only works if the configured Store is also synchronous.\n     *\n     * @param url - The domain to store the cookie with.\n     * @param options - Configuration settings to use when retrieving the cookies.\n     */\n    getCookieStringSync(url, options) {\n        return (this.callSync(options\n            ? this.getCookieString.bind(this, url, options)\n            : this.getCookieString.bind(this, url)) ?? '');\n    }\n    /**\n     * @internal No doc because this is the overload implementation\n     */\n    getSetCookieStrings(url, options, callback) {\n        if (typeof options === 'function') {\n            callback = options;\n            options = undefined;\n        }\n        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n        const next = function (err, cookies) {\n            if (err) {\n                promiseCallback.callback(err);\n            }\n            else {\n                promiseCallback.callback(null, cookies?.map((c) => {\n                    return c.toString();\n                }));\n            }\n        };\n        this.getCookies(url, options, next);\n        return promiseCallback.promise;\n    }\n    /**\n     * Synchronous version of `.getSetCookieStrings()`. Returns an array of strings suitable for `Set-Cookie` headers.\n     * Accepts the same options as `.getCookies()`.\n     *\n     * <strong>Note</strong>: Only works if the configured Store is also synchronous.\n     *\n     * @param url - The domain to store the cookie with.\n     * @param options - Configuration settings to use when retrieving the cookies.\n     */\n    getSetCookieStringsSync(url, options = {}) {\n        return (this.callSync(this.getSetCookieStrings.bind(this, url, options)) ?? []);\n    }\n    /**\n     * @internal No doc because this is the overload implementation\n     */\n    serialize(callback) {\n        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n        let type = this.store.constructor.name;\n        if (validators.isObject(type)) {\n            type = null;\n        }\n        // update README.md \"Serialization Format\" if you change this, please!\n        const serialized = {\n            // The version of tough-cookie that serialized this jar. Generally a good\n            // practice since future versions can make data import decisions based on\n            // known past behavior. When/if this matters, use `semver`.\n            version: `tough-cookie@${version_1.version}`,\n            // add the store type, to make humans happy:\n            storeType: type,\n            // CookieJar configuration:\n            rejectPublicSuffixes: this.rejectPublicSuffixes,\n            enableLooseMode: this.enableLooseMode,\n            allowSpecialUseDomain: this.allowSpecialUseDomain,\n            prefixSecurity: getNormalizedPrefixSecurity(this.prefixSecurity),\n            // this gets filled from getAllCookies:\n            cookies: [],\n        };\n        if (typeof this.store.getAllCookies !== 'function') {\n            return promiseCallback.reject(new Error('store does not support getAllCookies and cannot be serialized'));\n        }\n        this.store.getAllCookies((err, cookies) => {\n            if (err) {\n                promiseCallback.callback(err);\n                return;\n            }\n            if (cookies == null) {\n                promiseCallback.callback(null, serialized);\n                return;\n            }\n            serialized.cookies = cookies.map((cookie) => {\n                // convert to serialized 'raw' cookies\n                const serializedCookie = cookie.toJSON();\n                // Remove the index so new ones get assigned during deserialization\n                delete serializedCookie.creationIndex;\n                return serializedCookie;\n            });\n            promiseCallback.callback(null, serialized);\n        });\n        return promiseCallback.promise;\n    }\n    /**\n     * Serialize the CookieJar if the underlying store supports `.getAllCookies`.\n     *\n     * <strong>Note</strong>: Only works if the configured Store is also synchronous.\n     */\n    serializeSync() {\n        return this.callSync((callback) => {\n            this.serialize(callback);\n        });\n    }\n    /**\n     * Alias of {@link CookieJar.serializeSync}. Allows the cookie to be serialized\n     * with `JSON.stringify(cookieJar)`.\n     */\n    toJSON() {\n        return this.serializeSync();\n    }\n    /**\n     * Use the class method CookieJar.deserialize instead of calling this directly\n     * @internal\n     */\n    _importCookies(serialized, callback) {\n        let cookies = undefined;\n        if (serialized &&\n            typeof serialized === 'object' &&\n            (0, utils_1.inOperator)('cookies', serialized) &&\n            Array.isArray(serialized.cookies)) {\n            cookies = serialized.cookies;\n        }\n        if (!cookies) {\n            callback(new Error('serialized jar has no cookies array'), undefined);\n            return;\n        }\n        cookies = cookies.slice(); // do not modify the original\n        const putNext = (err) => {\n            if (err) {\n                callback(err, undefined);\n                return;\n            }\n            if (Array.isArray(cookies)) {\n                if (!cookies.length) {\n                    callback(err, this);\n                    return;\n                }\n                let cookie;\n                try {\n                    cookie = cookie_1.Cookie.fromJSON(cookies.shift());\n                }\n                catch (e) {\n                    callback(e instanceof Error ? e : new Error(), undefined);\n                    return;\n                }\n                if (cookie === undefined) {\n                    putNext(null); // skip this cookie\n                    return;\n                }\n                this.store.putCookie(cookie, putNext);\n            }\n        };\n        putNext(null);\n    }\n    /**\n     * @internal\n     */\n    _importCookiesSync(serialized) {\n        this.callSync(this._importCookies.bind(this, serialized));\n    }\n    /**\n     * @internal No doc because this is the overload implementation\n     */\n    clone(newStore, callback) {\n        if (typeof newStore === 'function') {\n            callback = newStore;\n            newStore = undefined;\n        }\n        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n        const cb = promiseCallback.callback;\n        this.serialize((err, serialized) => {\n            if (err) {\n                return promiseCallback.reject(err);\n            }\n            return CookieJar.deserialize(serialized ?? '', newStore, cb);\n        });\n        return promiseCallback.promise;\n    }\n    /**\n     * @internal\n     */\n    _cloneSync(newStore) {\n        const cloneFn = newStore && typeof newStore !== 'function'\n            ? this.clone.bind(this, newStore)\n            : this.clone.bind(this);\n        return this.callSync((callback) => {\n            cloneFn(callback);\n        });\n    }\n    /**\n     * Produces a deep clone of this CookieJar. Modifications to the original do\n     * not affect the clone, and vice versa.\n     *\n     * <strong>Note</strong>: Only works if both the configured Store and destination\n     * Store are synchronous.\n     *\n     * @remarks\n     * - When no {@link Store} is provided, a new {@link MemoryCookieStore} will be used.\n     *\n     * - Transferring between store types is supported so long as the source\n     *     implements `.getAllCookies()` and the destination implements `.putCookie()`.\n     *\n     * @param newStore - The target {@link Store} to clone cookies into.\n     */\n    cloneSync(newStore) {\n        if (!newStore) {\n            return this._cloneSync();\n        }\n        if (!newStore.synchronous) {\n            throw new Error('CookieJar clone destination store is not synchronous; use async API instead.');\n        }\n        return this._cloneSync(newStore);\n    }\n    /**\n     * @internal No doc because this is the overload implementation\n     */\n    removeAllCookies(callback) {\n        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n        const cb = promiseCallback.callback;\n        const store = this.store;\n        // Check that the store implements its own removeAllCookies(). The default\n        // implementation in Store will immediately call the callback with a \"not\n        // implemented\" Error.\n        if (typeof store.removeAllCookies === 'function' &&\n            store.removeAllCookies !== store_1.Store.prototype.removeAllCookies) {\n            // `Callback<undefined>` and `ErrorCallback` are *technically* incompatible, but for the\n            // standard implementation `cb = (err, result) => {}`, they're essentially the same.\n            store.removeAllCookies(cb);\n            return promiseCallback.promise;\n        }\n        store.getAllCookies((err, cookies) => {\n            if (err) {\n                cb(err);\n                return;\n            }\n            if (!cookies) {\n                cookies = [];\n            }\n            if (cookies.length === 0) {\n                cb(null, undefined);\n                return;\n            }\n            let completedCount = 0;\n            const removeErrors = [];\n            // TODO: Refactor to avoid using callback\n            const removeCookieCb = function removeCookieCb(removeErr) {\n                if (removeErr) {\n                    removeErrors.push(removeErr);\n                }\n                completedCount++;\n                if (completedCount === cookies.length) {\n                    if (removeErrors[0])\n                        cb(removeErrors[0]);\n                    else\n                        cb(null, undefined);\n                    return;\n                }\n            };\n            cookies.forEach((cookie) => {\n                store.removeCookie(cookie.domain, cookie.path, cookie.key, removeCookieCb);\n            });\n        });\n        return promiseCallback.promise;\n    }\n    /**\n     * Removes all cookies from the CookieJar.\n     *\n     * <strong>Note</strong>: Only works if the configured Store is also synchronous.\n     *\n     * @remarks\n     * - This is a new backwards-compatible feature of tough-cookie version 2.5,\n     *     so not all Stores will implement it efficiently. For Stores that do not\n     *     implement `removeAllCookies`, the fallback is to call `removeCookie` after\n     *     `getAllCookies`.\n     *\n     * - If `getAllCookies` fails or isn't implemented in the Store, an error is returned.\n     *\n     * - If one or more of the `removeCookie` calls fail, only the first error is returned.\n     */\n    removeAllCookiesSync() {\n        this.callSync((callback) => {\n            // `Callback<undefined>` and `ErrorCallback` are *technically* incompatible, but for the\n            // standard implementation `cb = (err, result) => {}`, they're essentially the same.\n            this.removeAllCookies(callback);\n        });\n    }\n    /**\n     * @internal No doc because this is the overload implementation\n     */\n    static deserialize(strOrObj, store, callback) {\n        if (typeof store === 'function') {\n            callback = store;\n            store = undefined;\n        }\n        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n        let serialized;\n        if (typeof strOrObj === 'string') {\n            try {\n                serialized = JSON.parse(strOrObj);\n            }\n            catch (e) {\n                return promiseCallback.reject(e instanceof Error ? e : new Error());\n            }\n        }\n        else {\n            serialized = strOrObj;\n        }\n        const readSerializedProperty = (property) => {\n            return serialized &&\n                typeof serialized === 'object' &&\n                (0, utils_1.inOperator)(property, serialized)\n                ? serialized[property]\n                : undefined;\n        };\n        const readSerializedBoolean = (property) => {\n            const value = readSerializedProperty(property);\n            return typeof value === 'boolean' ? value : undefined;\n        };\n        const readSerializedString = (property) => {\n            const value = readSerializedProperty(property);\n            return typeof value === 'string' ? value : undefined;\n        };\n        const jar = new CookieJar(store, {\n            rejectPublicSuffixes: readSerializedBoolean('rejectPublicSuffixes'),\n            looseMode: readSerializedBoolean('enableLooseMode'),\n            allowSpecialUseDomain: readSerializedBoolean('allowSpecialUseDomain'),\n            prefixSecurity: getNormalizedPrefixSecurity(readSerializedString('prefixSecurity') ?? 'silent'),\n        });\n        jar._importCookies(serialized, (err) => {\n            if (err) {\n                promiseCallback.callback(err);\n                return;\n            }\n            promiseCallback.callback(null, jar);\n        });\n        return promiseCallback.promise;\n    }\n    /**\n     * A new CookieJar is created and the serialized {@link Cookie} values are added to\n     * the underlying store. Each {@link Cookie} is added via `store.putCookie(...)` in\n     * the order in which they appear in the serialization.\n     *\n     * <strong>Note</strong>: Only works if the configured Store is also synchronous.\n     *\n     * @remarks\n     * - When no {@link Store} is provided, a new {@link MemoryCookieStore} will be used.\n     *\n     * - As a convenience, if `strOrObj` is a string, it is passed through `JSON.parse` first.\n     *\n     * @param strOrObj - A JSON string or object representing the deserialized cookies.\n     * @param store - The underlying store to persist the deserialized cookies into.\n     */\n    static deserializeSync(strOrObj, store) {\n        const serialized = typeof strOrObj === 'string' ? JSON.parse(strOrObj) : strOrObj;\n        const readSerializedProperty = (property) => {\n            return serialized &&\n                typeof serialized === 'object' &&\n                (0, utils_1.inOperator)(property, serialized)\n                ? serialized[property]\n                : undefined;\n        };\n        const readSerializedBoolean = (property) => {\n            const value = readSerializedProperty(property);\n            return typeof value === 'boolean' ? value : undefined;\n        };\n        const readSerializedString = (property) => {\n            const value = readSerializedProperty(property);\n            return typeof value === 'string' ? value : undefined;\n        };\n        const jar = new CookieJar(store, {\n            rejectPublicSuffixes: readSerializedBoolean('rejectPublicSuffixes'),\n            looseMode: readSerializedBoolean('enableLooseMode'),\n            allowSpecialUseDomain: readSerializedBoolean('allowSpecialUseDomain'),\n            prefixSecurity: getNormalizedPrefixSecurity(readSerializedString('prefixSecurity') ?? 'silent'),\n        });\n        // catch this mistake early:\n        if (!jar.store.synchronous) {\n            throw new Error('CookieJar store is not synchronous; use async API instead.');\n        }\n        jar._importCookiesSync(serialized);\n        return jar;\n    }\n    /**\n     * Alias of {@link CookieJar.deserializeSync}.\n     *\n     * @remarks\n     * - When no {@link Store} is provided, a new {@link MemoryCookieStore} will be used.\n     *\n     * - As a convenience, if `strOrObj` is a string, it is passed through `JSON.parse` first.\n     *\n     * @param jsonString - A JSON string or object representing the deserialized cookies.\n     * @param store - The underlying store to persist the deserialized cookies into.\n     */\n    static fromJSON(jsonString, store) {\n        return CookieJar.deserializeSync(jsonString, store);\n    }\n}\nexports.CookieJar = CookieJar;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}