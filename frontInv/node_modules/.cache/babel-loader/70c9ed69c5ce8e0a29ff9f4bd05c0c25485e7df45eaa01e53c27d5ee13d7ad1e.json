{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.set.difference.v2.js\");\nrequire(\"core-js/modules/es.set.intersection.v2.js\");\nrequire(\"core-js/modules/es.set.is-disjoint-from.v2.js\");\nrequire(\"core-js/modules/es.set.is-subset-of.v2.js\");\nrequire(\"core-js/modules/es.set.is-superset-of.v2.js\");\nrequire(\"core-js/modules/es.set.symmetric-difference.v2.js\");\nrequire(\"core-js/modules/es.set.union.v2.js\");\nconst nodeURL = require(\"url\");\nconst DOMException = require(\"../generated/DOMException\");\nconst {\n  parseURL,\n  serializeURL,\n  serializeURLOrigin\n} = require(\"whatwg-url\");\nconst WebSocket = require(\"ws\");\nconst {\n  setupForSimpleEventAccessors\n} = require(\"../helpers/create-event-accessor\");\nconst {\n  fireAnEvent\n} = require(\"../helpers/events\");\nconst {\n  isArrayBuffer\n} = require(\"../generated/utils\");\nconst {\n  copyToArrayBufferInNewRealm\n} = require(\"../helpers/binary-data\");\nconst EventTargetImpl = require(\"../events/EventTarget-impl\").implementation;\nconst idlUtils = require(\"../generated/utils\");\nconst Blob = require(\"../generated/Blob\");\nconst CloseEvent = require(\"../generated/CloseEvent\");\nconst MessageEvent = require(\"../generated/MessageEvent\");\nconst CONNECTING = 0;\nconst OPEN = 1;\nconst CLOSING = 2;\nconst CLOSED = 3;\nconst productions = {\n  // https://tools.ietf.org/html/rfc7230#section-3.2.6\n  token: /^[!#$%&'*+\\-.^_`|~\\dA-Za-z]+$/\n};\nconst readyStateWSToDOM = [];\nreadyStateWSToDOM[WebSocket.CONNECTING] = CONNECTING;\nreadyStateWSToDOM[WebSocket.OPEN] = OPEN;\nreadyStateWSToDOM[WebSocket.CLOSING] = CLOSING;\nreadyStateWSToDOM[WebSocket.CLOSED] = CLOSED;\n\n// https://tools.ietf.org/html/rfc6455#section-4.3\n// See Sec-WebSocket-Protocol-Client, which is for the syntax of an entire header value. This function checks if a\n// single header conforms to the rules.\nfunction verifySecWebSocketProtocol(str) {\n  return productions.token.test(str);\n}\nclass PromiseQueues extends WeakMap {\n  get(window) {\n    const cur = super.get(window);\n    return cur !== undefined ? cur : Promise.resolve();\n  }\n}\nconst openSockets = new WeakMap();\nconst openingQueues = new PromiseQueues();\nclass WebSocketImpl extends EventTargetImpl {\n  constructor(globalObject, args, privateData) {\n    super(globalObject, args, privateData);\n    this._ownerDocument = idlUtils.implForWrapper(globalObject._document);\n    const url = args[0];\n    let protocols = args[1] !== undefined ? args[1] : [];\n    const urlRecord = parseURL(url);\n    if (urlRecord === null) {\n      throw DOMException.create(this._globalObject, [`The URL '${url}' is invalid.`, \"SyntaxError\"]);\n    }\n    if (urlRecord.scheme !== \"ws\" && urlRecord.scheme !== \"wss\") {\n      throw DOMException.create(this._globalObject, [`The URL's scheme must be either 'ws' or 'wss'. '${urlRecord.scheme}' is not allowed.`, \"SyntaxError\"]);\n    }\n    if (urlRecord.fragment !== null) {\n      throw DOMException.create(this._globalObject, [`The URL contains a fragment identifier ('${urlRecord.fragment}'). Fragment identifiers ` + \"are not allowed in WebSocket URLs.\", \"SyntaxError\"]);\n    }\n    if (typeof protocols === \"string\") {\n      protocols = [protocols];\n    }\n    const protocolSet = new Set();\n    for (const protocol of protocols) {\n      if (!verifySecWebSocketProtocol(protocol)) {\n        throw DOMException.create(this._globalObject, [`The subprotocol '${protocol}' is invalid.`, \"SyntaxError\"]);\n      }\n      const lowered = protocol.toLowerCase();\n      if (protocolSet.has(lowered)) {\n        throw DOMException.create(this._globalObject, [`The subprotocol '${protocol}' is duplicated.`, \"SyntaxError\"]);\n      }\n      protocolSet.add(lowered);\n    }\n    this._urlRecord = urlRecord;\n    this.url = serializeURL(urlRecord);\n    const nodeParsedURL = nodeURL.parse(this.url);\n    this.extensions = \"\";\n    this.binaryType = \"blob\";\n    this._ws = null;\n    // Used when this._ws has not been initialized yet.\n    this._readyState = CONNECTING;\n    this._requiredToFail = false;\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n    let openSocketsForWindow = openSockets.get(globalObject._globalProxy);\n    if (openSocketsForWindow === undefined) {\n      openSocketsForWindow = new Set();\n      openSockets.set(globalObject._globalProxy, openSocketsForWindow);\n    }\n    openSocketsForWindow.add(this);\n    openingQueues.set(this._ownerDocument, openingQueues.get(this._ownerDocument).then(() => new Promise(resolve => {\n      // close() called before _ws has been initialized.\n      if (this._requiredToFail) {\n        resolve();\n        this._readyState = CLOSED;\n        this._onConnectionClosed(1006, \"\");\n        return;\n      }\n      this._ws = new WebSocket(this.url, protocols, {\n        headers: {\n          \"user-agent\": globalObject.navigator.userAgent,\n          \"cookie\": this._ownerDocument._cookieJar.getCookieStringSync(nodeParsedURL, {\n            http: true\n          }),\n          \"origin\": globalObject._origin\n        },\n        rejectUnauthorized: globalObject._resourceLoader._strictSSL\n      });\n      this._ws.once(\"open\", () => {\n        resolve();\n        this._onConnectionEstablished();\n      });\n      this._ws.on(\"message\", this._onMessageReceived.bind(this));\n      this._ws.once(\"close\", (...closeArgs) => {\n        resolve();\n        this._onConnectionClosed(...closeArgs);\n      });\n      this._ws.once(\"upgrade\", ({\n        headers\n      }) => {\n        if (Array.isArray(headers[\"set-cookie\"])) {\n          for (const cookie of headers[\"set-cookie\"]) {\n            this._ownerDocument._cookieJar.setCookieSync(cookie, nodeParsedURL, {\n              http: true,\n              ignoreError: true\n            });\n          }\n        } else if (headers[\"set-cookie\"] !== undefined) {\n          this._ownerDocument._cookieJar.setCookieSync(headers[\"set-cookie\"], nodeParsedURL, {\n            http: true,\n            ignoreError: true\n          });\n        }\n      });\n      this._ws.once(\"error\", () => {\n        // The exact error is passed into this callback, but it is ignored as we don't really care about it.\n        resolve();\n        this._requiredToFail = true;\n        // Do not emit an error here, as that will be handled in _onConnectionClosed. ws always emits a close event\n        // after errors.\n      });\n    })));\n  }\n\n  // https://html.spec.whatwg.org/multipage/web-sockets.html#make-disappear\n  _makeDisappear() {\n    this._eventListeners = Object.create(null);\n    this._close(1001);\n  }\n  static cleanUpWindow(window) {\n    const openSocketsForWindow = openSockets.get(window._globalProxy);\n    if (openSocketsForWindow !== undefined) {\n      for (const ws of openSocketsForWindow) {\n        ws._makeDisappear();\n      }\n    }\n  }\n\n  // https://html.spec.whatwg.org/multipage/web-sockets.html#feedback-from-the-protocol\n  _onConnectionEstablished() {\n    // readyState is a getter.\n    if (this._ws.extensions !== null) {\n      // Right now, ws only supports one extension, permessage-deflate, without any parameters. This algorithm may need\n      // to be more sophiscated as more extenions are supported.\n      this.extensions = Object.keys(this._ws.extensions).join(\", \");\n    }\n    // protocol is a getter.\n    fireAnEvent(\"open\", this);\n  }\n  _onMessageReceived(data, isBinary) {\n    if (this.readyState !== OPEN) {\n      return;\n    }\n    let dataForEvent;\n    if (!isBinary) {\n      dataForEvent = data.toString();\n    } else if (this.binaryType === \"arraybuffer\") {\n      if (isArrayBuffer(data)) {\n        dataForEvent = data;\n      } else if (Array.isArray(data)) {\n        dataForEvent = copyToArrayBufferInNewRealm(Buffer.concat(data), this._globalObject);\n      } else {\n        dataForEvent = copyToArrayBufferInNewRealm(data, this._globalObject);\n      }\n    } else {\n      // this.binaryType === \"blob\"\n      if (!Array.isArray(data)) {\n        data = [data];\n      }\n      dataForEvent = Blob.create(this._globalObject, [data, {\n        type: \"\"\n      }]);\n    }\n    fireAnEvent(\"message\", this, MessageEvent, {\n      data: dataForEvent,\n      origin: serializeURLOrigin(this._urlRecord)\n    });\n  }\n  _onConnectionClosed(code, reason) {\n    const openSocketsForWindow = openSockets.get(this._ownerDocument._defaultView);\n    openSocketsForWindow.delete(this);\n    const wasClean = !this._requiredToFail;\n    if (this._requiredToFail) {\n      fireAnEvent(\"error\", this);\n    }\n    fireAnEvent(\"close\", this, CloseEvent, {\n      wasClean,\n      code,\n      reason: reason.toString()\n    });\n  }\n  get readyState() {\n    if (this._ws !== null) {\n      return readyStateWSToDOM[this._ws.readyState];\n    }\n    return this._readyState;\n  }\n  get protocol() {\n    if (this._ws === null) {\n      return \"\";\n    }\n    return this._ws.protocol;\n  }\n  close(code = undefined, reason = undefined) {\n    if (code !== undefined && code !== 1000 && !(code >= 3000 && code <= 4999)) {\n      throw DOMException.create(this._globalObject, [`The code must be either 1000, or between 3000 and 4999. ${code} is neither.`, \"InvalidAccessError\"]);\n    }\n    if (reason !== undefined && Buffer.byteLength(reason, \"utf8\") > 123) {\n      throw DOMException.create(this._globalObject, [\"The message must not be greater than 123 bytes.\", \"SyntaxError\"]);\n    }\n    this._close(code, reason);\n  }\n  _close(code = undefined, reason = undefined) {\n    if (this.readyState === CONNECTING) {\n      this._requiredToFail = true;\n      if (this._ws !== null) {\n        this._ws.terminate();\n      } else {\n        this._readyState = CLOSING;\n      }\n    } else if (this.readyState === OPEN) {\n      this._ws.close(code, reason);\n    }\n  }\n  send(data) {\n    if (this.readyState === CONNECTING) {\n      throw DOMException.create(this._globalObject, [\"Still in CONNECTING state.\", \"InvalidStateError\"]);\n    }\n    if (this.readyState !== OPEN) {\n      return;\n    }\n    if (Blob.isImpl(data)) {\n      data = data._buffer;\n    }\n    let length;\n    if (typeof data === \"string\") {\n      length = Buffer.byteLength(data, \"utf8\");\n    } else {\n      length = data.byteLength;\n    }\n    this.bufferedAmount += length;\n    this._sendQueue.push([data, length]);\n    this._scheduleSend();\n  }\n  _actuallySend() {\n    for (const [data, length] of this._sendQueue.splice(0)) {\n      this._ws.send(data, {\n        binary: typeof data !== \"string\"\n      }, () => {\n        this.bufferedAmount -= length;\n      });\n    }\n  }\n  _scheduleSend() {\n    if (this._dequeueScheduled) {\n      return;\n    }\n    this._dequeueScheduled = true;\n    process.nextTick(() => {\n      this._dequeueScheduled = false;\n      this._actuallySend();\n    });\n  }\n}\nsetupForSimpleEventAccessors(WebSocketImpl.prototype, [\"open\", \"message\", \"error\", \"close\"]);\nexports.implementation = WebSocketImpl;","map":{"version":3,"names":["require","nodeURL","DOMException","parseURL","serializeURL","serializeURLOrigin","WebSocket","setupForSimpleEventAccessors","fireAnEvent","isArrayBuffer","copyToArrayBufferInNewRealm","EventTargetImpl","implementation","idlUtils","Blob","CloseEvent","MessageEvent","CONNECTING","OPEN","CLOSING","CLOSED","productions","token","readyStateWSToDOM","verifySecWebSocketProtocol","str","test","PromiseQueues","WeakMap","get","window","cur","undefined","Promise","resolve","openSockets","openingQueues","WebSocketImpl","constructor","globalObject","args","privateData","_ownerDocument","implForWrapper","_document","url","protocols","urlRecord","create","_globalObject","scheme","fragment","protocolSet","Set","protocol","lowered","toLowerCase","has","add","_urlRecord","nodeParsedURL","parse","extensions","binaryType","_ws","_readyState","_requiredToFail","bufferedAmount","_sendQueue","openSocketsForWindow","_globalProxy","set","then","_onConnectionClosed","headers","navigator","userAgent","_cookieJar","getCookieStringSync","http","_origin","rejectUnauthorized","_resourceLoader","_strictSSL","once","_onConnectionEstablished","on","_onMessageReceived","bind","closeArgs","Array","isArray","cookie","setCookieSync","ignoreError","_makeDisappear","_eventListeners","Object","_close","cleanUpWindow","ws","keys","join","data","isBinary","readyState","dataForEvent","toString","Buffer","concat","type","origin","code","reason","_defaultView","delete","wasClean","close","byteLength","terminate","send","isImpl","_buffer","length","push","_scheduleSend","_actuallySend","splice","binary","_dequeueScheduled","process","nextTick","prototype","exports"],"sources":["/Users/feyraf/Desktop/projets/Roma/invest/node_modules/jsdom/lib/jsdom/living/websockets/WebSocket-impl.js"],"sourcesContent":["\"use strict\";\n\nconst nodeURL = require(\"url\");\n\nconst DOMException = require(\"../generated/DOMException\");\nconst { parseURL, serializeURL, serializeURLOrigin } = require(\"whatwg-url\");\nconst WebSocket = require(\"ws\");\n\nconst { setupForSimpleEventAccessors } = require(\"../helpers/create-event-accessor\");\nconst { fireAnEvent } = require(\"../helpers/events\");\nconst { isArrayBuffer } = require(\"../generated/utils\");\nconst { copyToArrayBufferInNewRealm } = require(\"../helpers/binary-data\");\n\nconst EventTargetImpl = require(\"../events/EventTarget-impl\").implementation;\n\nconst idlUtils = require(\"../generated/utils\");\nconst Blob = require(\"../generated/Blob\");\nconst CloseEvent = require(\"../generated/CloseEvent\");\nconst MessageEvent = require(\"../generated/MessageEvent\");\n\nconst CONNECTING = 0;\nconst OPEN = 1;\nconst CLOSING = 2;\nconst CLOSED = 3;\n\nconst productions = {\n  // https://tools.ietf.org/html/rfc7230#section-3.2.6\n  token: /^[!#$%&'*+\\-.^_`|~\\dA-Za-z]+$/\n};\n\nconst readyStateWSToDOM = [];\nreadyStateWSToDOM[WebSocket.CONNECTING] = CONNECTING;\nreadyStateWSToDOM[WebSocket.OPEN] = OPEN;\nreadyStateWSToDOM[WebSocket.CLOSING] = CLOSING;\nreadyStateWSToDOM[WebSocket.CLOSED] = CLOSED;\n\n// https://tools.ietf.org/html/rfc6455#section-4.3\n// See Sec-WebSocket-Protocol-Client, which is for the syntax of an entire header value. This function checks if a\n// single header conforms to the rules.\nfunction verifySecWebSocketProtocol(str) {\n  return productions.token.test(str);\n}\n\nclass PromiseQueues extends WeakMap {\n  get(window) {\n    const cur = super.get(window);\n    return cur !== undefined ? cur : Promise.resolve();\n  }\n}\n\nconst openSockets = new WeakMap();\nconst openingQueues = new PromiseQueues();\n\nclass WebSocketImpl extends EventTargetImpl {\n  constructor(globalObject, args, privateData) {\n    super(globalObject, args, privateData);\n\n    this._ownerDocument = idlUtils.implForWrapper(globalObject._document);\n\n    const url = args[0];\n    let protocols = args[1] !== undefined ? args[1] : [];\n\n    const urlRecord = parseURL(url);\n    if (urlRecord === null) {\n      throw DOMException.create(this._globalObject, [`The URL '${url}' is invalid.`, \"SyntaxError\"]);\n    }\n    if (urlRecord.scheme !== \"ws\" && urlRecord.scheme !== \"wss\") {\n      throw DOMException.create(this._globalObject, [\n        `The URL's scheme must be either 'ws' or 'wss'. '${urlRecord.scheme}' is not allowed.`,\n        \"SyntaxError\"\n      ]);\n    }\n    if (urlRecord.fragment !== null) {\n      throw DOMException.create(this._globalObject, [\n        `The URL contains a fragment identifier ('${urlRecord.fragment}'). Fragment identifiers ` +\n        \"are not allowed in WebSocket URLs.\",\n        \"SyntaxError\"\n      ]);\n    }\n\n    if (typeof protocols === \"string\") {\n      protocols = [protocols];\n    }\n    const protocolSet = new Set();\n    for (const protocol of protocols) {\n      if (!verifySecWebSocketProtocol(protocol)) {\n        throw DOMException.create(this._globalObject, [`The subprotocol '${protocol}' is invalid.`, \"SyntaxError\"]);\n      }\n      const lowered = protocol.toLowerCase();\n      if (protocolSet.has(lowered)) {\n        throw DOMException.create(this._globalObject, [\n          `The subprotocol '${protocol}' is duplicated.`,\n          \"SyntaxError\"\n        ]);\n      }\n      protocolSet.add(lowered);\n    }\n\n    this._urlRecord = urlRecord;\n    this.url = serializeURL(urlRecord);\n    const nodeParsedURL = nodeURL.parse(this.url);\n    this.extensions = \"\";\n\n    this.binaryType = \"blob\";\n\n    this._ws = null;\n    // Used when this._ws has not been initialized yet.\n    this._readyState = CONNECTING;\n    this._requiredToFail = false;\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n\n    let openSocketsForWindow = openSockets.get(globalObject._globalProxy);\n    if (openSocketsForWindow === undefined) {\n      openSocketsForWindow = new Set();\n      openSockets.set(globalObject._globalProxy, openSocketsForWindow);\n    }\n    openSocketsForWindow.add(this);\n\n    openingQueues.set(this._ownerDocument, openingQueues.get(this._ownerDocument).then(() => new Promise(resolve => {\n      // close() called before _ws has been initialized.\n      if (this._requiredToFail) {\n        resolve();\n        this._readyState = CLOSED;\n        this._onConnectionClosed(1006, \"\");\n        return;\n      }\n\n      this._ws = new WebSocket(this.url, protocols, {\n        headers: {\n          \"user-agent\": globalObject.navigator.userAgent,\n          \"cookie\": this._ownerDocument._cookieJar.getCookieStringSync(nodeParsedURL, { http: true }),\n          \"origin\": globalObject._origin\n        },\n        rejectUnauthorized: globalObject._resourceLoader._strictSSL\n      });\n      this._ws.once(\"open\", () => {\n        resolve();\n        this._onConnectionEstablished();\n      });\n      this._ws.on(\"message\", this._onMessageReceived.bind(this));\n      this._ws.once(\"close\", (...closeArgs) => {\n        resolve();\n        this._onConnectionClosed(...closeArgs);\n      });\n      this._ws.once(\"upgrade\", ({ headers }) => {\n        if (Array.isArray(headers[\"set-cookie\"])) {\n          for (const cookie of headers[\"set-cookie\"]) {\n            this._ownerDocument._cookieJar.setCookieSync(\n              cookie,\n              nodeParsedURL,\n              { http: true, ignoreError: true }\n            );\n          }\n        } else if (headers[\"set-cookie\"] !== undefined) {\n          this._ownerDocument._cookieJar.setCookieSync(\n            headers[\"set-cookie\"],\n            nodeParsedURL,\n            { http: true, ignoreError: true }\n          );\n        }\n      });\n      this._ws.once(\"error\", () => {\n        // The exact error is passed into this callback, but it is ignored as we don't really care about it.\n        resolve();\n        this._requiredToFail = true;\n        // Do not emit an error here, as that will be handled in _onConnectionClosed. ws always emits a close event\n        // after errors.\n      });\n    })));\n  }\n\n  // https://html.spec.whatwg.org/multipage/web-sockets.html#make-disappear\n  _makeDisappear() {\n    this._eventListeners = Object.create(null);\n    this._close(1001);\n  }\n\n  static cleanUpWindow(window) {\n    const openSocketsForWindow = openSockets.get(window._globalProxy);\n    if (openSocketsForWindow !== undefined) {\n      for (const ws of openSocketsForWindow) {\n        ws._makeDisappear();\n      }\n    }\n  }\n\n  // https://html.spec.whatwg.org/multipage/web-sockets.html#feedback-from-the-protocol\n  _onConnectionEstablished() {\n    // readyState is a getter.\n    if (this._ws.extensions !== null) {\n      // Right now, ws only supports one extension, permessage-deflate, without any parameters. This algorithm may need\n      // to be more sophiscated as more extenions are supported.\n      this.extensions = Object.keys(this._ws.extensions).join(\", \");\n    }\n    // protocol is a getter.\n    fireAnEvent(\"open\", this);\n  }\n\n  _onMessageReceived(data, isBinary) {\n    if (this.readyState !== OPEN) {\n      return;\n    }\n    let dataForEvent;\n    if (!isBinary) {\n      dataForEvent = data.toString();\n    } else if (this.binaryType === \"arraybuffer\") {\n      if (isArrayBuffer(data)) {\n        dataForEvent = data;\n      } else if (Array.isArray(data)) {\n        dataForEvent = copyToArrayBufferInNewRealm(Buffer.concat(data), this._globalObject);\n      } else {\n        dataForEvent = copyToArrayBufferInNewRealm(data, this._globalObject);\n      }\n    } else { // this.binaryType === \"blob\"\n      if (!Array.isArray(data)) {\n        data = [data];\n      }\n      dataForEvent = Blob.create(this._globalObject, [data, { type: \"\" }]);\n    }\n    fireAnEvent(\"message\", this, MessageEvent, {\n      data: dataForEvent,\n      origin: serializeURLOrigin(this._urlRecord)\n    });\n  }\n\n  _onConnectionClosed(code, reason) {\n    const openSocketsForWindow = openSockets.get(this._ownerDocument._defaultView);\n    openSocketsForWindow.delete(this);\n\n    const wasClean = !this._requiredToFail;\n    if (this._requiredToFail) {\n      fireAnEvent(\"error\", this);\n    }\n    fireAnEvent(\"close\", this, CloseEvent, {\n      wasClean,\n      code,\n      reason: reason.toString()\n    });\n  }\n\n  get readyState() {\n    if (this._ws !== null) {\n      return readyStateWSToDOM[this._ws.readyState];\n    }\n    return this._readyState;\n  }\n\n  get protocol() {\n    if (this._ws === null) {\n      return \"\";\n    }\n    return this._ws.protocol;\n  }\n\n  close(code = undefined, reason = undefined) {\n    if (code !== undefined && code !== 1000 && !(code >= 3000 && code <= 4999)) {\n      throw DOMException.create(this._globalObject, [\n        `The code must be either 1000, or between 3000 and 4999. ${code} is neither.`,\n        \"InvalidAccessError\"\n      ]);\n    }\n    if (reason !== undefined && Buffer.byteLength(reason, \"utf8\") > 123) {\n      throw DOMException.create(this._globalObject, [\n        \"The message must not be greater than 123 bytes.\",\n        \"SyntaxError\"\n      ]);\n    }\n    this._close(code, reason);\n  }\n\n  _close(code = undefined, reason = undefined) {\n    if (this.readyState === CONNECTING) {\n      this._requiredToFail = true;\n      if (this._ws !== null) {\n        this._ws.terminate();\n      } else {\n        this._readyState = CLOSING;\n      }\n    } else if (this.readyState === OPEN) {\n      this._ws.close(code, reason);\n    }\n  }\n\n  send(data) {\n    if (this.readyState === CONNECTING) {\n      throw DOMException.create(this._globalObject, [\"Still in CONNECTING state.\", \"InvalidStateError\"]);\n    }\n    if (this.readyState !== OPEN) {\n      return;\n    }\n    if (Blob.isImpl(data)) {\n      data = data._buffer;\n    }\n    let length;\n    if (typeof data === \"string\") {\n      length = Buffer.byteLength(data, \"utf8\");\n    } else {\n      length = data.byteLength;\n    }\n    this.bufferedAmount += length;\n    this._sendQueue.push([data, length]);\n    this._scheduleSend();\n  }\n\n  _actuallySend() {\n    for (const [data, length] of this._sendQueue.splice(0)) {\n      this._ws.send(data, { binary: typeof data !== \"string\" }, () => {\n        this.bufferedAmount -= length;\n      });\n    }\n  }\n\n  _scheduleSend() {\n    if (this._dequeueScheduled) {\n      return;\n    }\n    this._dequeueScheduled = true;\n    process.nextTick(() => {\n      this._dequeueScheduled = false;\n      this._actuallySend();\n    });\n  }\n}\n\nsetupForSimpleEventAccessors(WebSocketImpl.prototype, [\"open\", \"message\", \"error\", \"close\"]);\n\nexports.implementation = WebSocketImpl;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}