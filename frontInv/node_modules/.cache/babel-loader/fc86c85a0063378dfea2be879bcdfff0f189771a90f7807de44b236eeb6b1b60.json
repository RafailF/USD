{"ast":null,"code":"\"use strict\";\n\nconst DOMException = require(\"../generated/DOMException\");\nconst {\n  documentBaseURLSerialized,\n  parseURLToResultingURLRecord\n} = require(\"../helpers/document-base-url.js\");\nconst {\n  serializeURL\n} = require(\"whatwg-url\");\n\n// https://html.spec.whatwg.org/#history-3\nexports.implementation = class HistoryImpl {\n  constructor(globalObject, args, privateData) {\n    this._window = privateData.window;\n    this._document = privateData.document;\n    this._actAsIfLocationReloadCalled = privateData.actAsIfLocationReloadCalled;\n    this._state = null;\n    this._globalObject = globalObject;\n  }\n  _guardAgainstInactiveDocuments() {\n    if (!this._window) {\n      throw DOMException.create(this._globalObject, [\"History object is associated with a document that is not fully active.\", \"SecurityError\"]);\n    }\n  }\n  get length() {\n    this._guardAgainstInactiveDocuments();\n    return this._window._sessionHistory.length;\n  }\n  get state() {\n    this._guardAgainstInactiveDocuments();\n    return this._state;\n  }\n  go(delta) {\n    this._guardAgainstInactiveDocuments();\n    if (delta === 0) {\n      // When the go(delta) method is invoked, if delta is zero, the user agent must act as\n      // if the location.reload() method was called instead.\n      this._actAsIfLocationReloadCalled();\n    } else {\n      // Otherwise, the user agent must traverse the history by a delta whose value is delta\n      this._window._sessionHistory.traverseByDelta(delta);\n    }\n  }\n  back() {\n    this.go(-1);\n  }\n  forward() {\n    this.go(+1);\n  }\n  pushState(data, unused, url) {\n    this._sharedPushAndReplaceState(data, url, \"push\");\n  }\n  replaceState(data, unused, url) {\n    this._sharedPushAndReplaceState(data, url, \"replace\");\n  }\n\n  // https://html.spec.whatwg.org/#shared-history-push/replace-state-steps\n  _sharedPushAndReplaceState(data, url, historyHandling) {\n    this._guardAgainstInactiveDocuments();\n\n    // TODO structured clone data\n\n    let newURL = this._document._URL;\n    if (url !== null && url.length > 0) {\n      newURL = parseURLToResultingURLRecord(url, this._document);\n      if (newURL === null) {\n        throw DOMException.create(this._globalObject, [`Could not parse url argument \"${url}\" to ${historyHandling}State() against base URL ` + `\"${documentBaseURLSerialized(this._document)}\".`, \"SecurityError\"]);\n      }\n      if (!canHaveItsURLRewritten(this._document, newURL)) {\n        throw DOMException.create(this._globalObject, [`${historyHandling}State() cannot update history to the URL ${serializeURL(newURL)}.`, \"SecurityError\"]);\n      }\n    }\n\n    // What follows is very unlike the spec's URL and history update steps. Maybe if we implement real session\n    // history/navigation, we can fix that.\n\n    if (historyHandling === \"push\") {\n      this._window._sessionHistory.removeAllEntriesAfterCurrentEntry();\n      this._window._sessionHistory.clearHistoryTraversalTasks();\n      const newEntry = {\n        document: this._document,\n        stateObject: data,\n        url: newURL\n      };\n      this._window._sessionHistory.addEntryAfterCurrentEntry(newEntry);\n      this._window._sessionHistory.updateCurrentEntry(newEntry);\n    } else {\n      const {\n        currentEntry\n      } = this._window._sessionHistory;\n      currentEntry.stateObject = data;\n      currentEntry.url = newURL;\n    }\n\n    // TODO: If the current entry in the session history represents a non-GET request\n    // (e.g. it was the result of a POST submission) then update it to instead represent\n    // a GET request.\n\n    this._document._URL = newURL;\n\n    // arguably it's a bit odd that the state and latestEntry do not belong to the SessionHistory\n    // but the spec gives them to \"History\" and \"Document\" respecively.\n    this._state = data; // TODO clone again!! O_o\n    this._document._latestEntry = this._window._sessionHistory.currentEntry;\n  }\n};\nfunction canHaveItsURLRewritten(document, targetURL) {\n  const documentURL = document._URL;\n  if (targetURL.scheme !== documentURL.scheme || targetURL.username !== documentURL.username || targetURL.password !== documentURL.password || targetURL.host !== documentURL.host || targetURL.port !== documentURL.port) {\n    return false;\n  }\n  if (targetURL.scheme === \"https\" || targetURL.scheme === \"http\") {\n    return true;\n  }\n  if (targetURL.scheme === \"file\" && targetURL.path !== documentURL.path) {\n    return false;\n  }\n  if (targetURL.path.join(\"/\") !== documentURL.path.join(\"/\") || targetURL.query !== documentURL.query) {\n    return false;\n  }\n  return true;\n}","map":{"version":3,"names":["DOMException","require","documentBaseURLSerialized","parseURLToResultingURLRecord","serializeURL","exports","implementation","HistoryImpl","constructor","globalObject","args","privateData","_window","window","_document","document","_actAsIfLocationReloadCalled","actAsIfLocationReloadCalled","_state","_globalObject","_guardAgainstInactiveDocuments","create","length","_sessionHistory","state","go","delta","traverseByDelta","back","forward","pushState","data","unused","url","_sharedPushAndReplaceState","replaceState","historyHandling","newURL","_URL","canHaveItsURLRewritten","removeAllEntriesAfterCurrentEntry","clearHistoryTraversalTasks","newEntry","stateObject","addEntryAfterCurrentEntry","updateCurrentEntry","currentEntry","_latestEntry","targetURL","documentURL","scheme","username","password","host","port","path","join","query"],"sources":["/Users/feyraf/Desktop/projets/Roma/invest/node_modules/jsdom/lib/jsdom/living/window/History-impl.js"],"sourcesContent":["\"use strict\";\nconst DOMException = require(\"../generated/DOMException\");\nconst { documentBaseURLSerialized, parseURLToResultingURLRecord } = require(\"../helpers/document-base-url.js\");\nconst { serializeURL } = require(\"whatwg-url\");\n\n// https://html.spec.whatwg.org/#history-3\nexports.implementation = class HistoryImpl {\n  constructor(globalObject, args, privateData) {\n    this._window = privateData.window;\n    this._document = privateData.document;\n    this._actAsIfLocationReloadCalled = privateData.actAsIfLocationReloadCalled;\n    this._state = null;\n\n    this._globalObject = globalObject;\n  }\n\n  _guardAgainstInactiveDocuments() {\n    if (!this._window) {\n      throw DOMException.create(this._globalObject, [\n        \"History object is associated with a document that is not fully active.\",\n        \"SecurityError\"\n      ]);\n    }\n  }\n\n  get length() {\n    this._guardAgainstInactiveDocuments();\n\n    return this._window._sessionHistory.length;\n  }\n\n  get state() {\n    this._guardAgainstInactiveDocuments();\n\n    return this._state;\n  }\n\n  go(delta) {\n    this._guardAgainstInactiveDocuments();\n\n    if (delta === 0) {\n      // When the go(delta) method is invoked, if delta is zero, the user agent must act as\n      // if the location.reload() method was called instead.\n      this._actAsIfLocationReloadCalled();\n    } else {\n      // Otherwise, the user agent must traverse the history by a delta whose value is delta\n      this._window._sessionHistory.traverseByDelta(delta);\n    }\n  }\n\n  back() {\n    this.go(-1);\n  }\n\n  forward() {\n    this.go(+1);\n  }\n\n  pushState(data, unused, url) {\n    this._sharedPushAndReplaceState(data, url, \"push\");\n  }\n  replaceState(data, unused, url) {\n    this._sharedPushAndReplaceState(data, url, \"replace\");\n  }\n\n  // https://html.spec.whatwg.org/#shared-history-push/replace-state-steps\n  _sharedPushAndReplaceState(data, url, historyHandling) {\n    this._guardAgainstInactiveDocuments();\n\n    // TODO structured clone data\n\n    let newURL = this._document._URL;\n    if (url !== null && url.length > 0) {\n      newURL = parseURLToResultingURLRecord(url, this._document);\n\n      if (newURL === null) {\n        throw DOMException.create(this._globalObject, [\n          `Could not parse url argument \"${url}\" to ${historyHandling}State() against base URL ` +\n          `\"${documentBaseURLSerialized(this._document)}\".`,\n          \"SecurityError\"\n        ]);\n      }\n\n      if (!canHaveItsURLRewritten(this._document, newURL)) {\n        throw DOMException.create(this._globalObject, [\n          `${historyHandling}State() cannot update history to the URL ${serializeURL(newURL)}.`,\n          \"SecurityError\"\n        ]);\n      }\n    }\n\n    // What follows is very unlike the spec's URL and history update steps. Maybe if we implement real session\n    // history/navigation, we can fix that.\n\n    if (historyHandling === \"push\") {\n      this._window._sessionHistory.removeAllEntriesAfterCurrentEntry();\n\n      this._window._sessionHistory.clearHistoryTraversalTasks();\n\n      const newEntry = {\n        document: this._document,\n        stateObject: data,\n        url: newURL\n      };\n      this._window._sessionHistory.addEntryAfterCurrentEntry(newEntry);\n      this._window._sessionHistory.updateCurrentEntry(newEntry);\n    } else {\n      const { currentEntry } = this._window._sessionHistory;\n      currentEntry.stateObject = data;\n      currentEntry.url = newURL;\n    }\n\n    // TODO: If the current entry in the session history represents a non-GET request\n    // (e.g. it was the result of a POST submission) then update it to instead represent\n    // a GET request.\n\n    this._document._URL = newURL;\n\n    // arguably it's a bit odd that the state and latestEntry do not belong to the SessionHistory\n    // but the spec gives them to \"History\" and \"Document\" respecively.\n    this._state = data; // TODO clone again!! O_o\n    this._document._latestEntry = this._window._sessionHistory.currentEntry;\n  }\n};\n\nfunction canHaveItsURLRewritten(document, targetURL) {\n  const documentURL = document._URL;\n\n  if (targetURL.scheme !== documentURL.scheme || targetURL.username !== documentURL.username ||\n      targetURL.password !== documentURL.password || targetURL.host !== documentURL.host ||\n      targetURL.port !== documentURL.port) {\n    return false;\n  }\n\n  if (targetURL.scheme === \"https\" || targetURL.scheme === \"http\") {\n    return true;\n  }\n\n  if (targetURL.scheme === \"file\" && targetURL.path !== documentURL.path) {\n    return false;\n  }\n\n  if (targetURL.path.join(\"/\") !== documentURL.path.join(\"/\") || targetURL.query !== documentURL.query) {\n    return false;\n  }\n\n  return true;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}