{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/esnext.iterator.constructor.js\");\nrequire(\"core-js/modules/esnext.iterator.for-each.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MemoryCookieStore = void 0;\nconst pathMatch_1 = require(\"./pathMatch\");\nconst permuteDomain_1 = require(\"./permuteDomain\");\nconst store_1 = require(\"./store\");\nconst utils_1 = require(\"./utils\");\n/**\n * An in-memory {@link Store} implementation for {@link CookieJar}. This is the default implementation used by\n * {@link CookieJar} and supports both async and sync operations. Also supports serialization, getAllCookies, and removeAllCookies.\n * @public\n */\nclass MemoryCookieStore extends store_1.Store {\n  /**\n   * Create a new {@link MemoryCookieStore}.\n   */\n  constructor() {\n    super();\n    this.synchronous = true;\n    this.idx = Object.create(null);\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  findCookie(domain, path, key, callback) {\n    const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n    if (domain == null || path == null || key == null) {\n      return promiseCallback.resolve(undefined);\n    }\n    const result = this.idx[domain]?.[path]?.[key];\n    return promiseCallback.resolve(result);\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  findCookies(domain, path, allowSpecialUseDomain = false, callback) {\n    if (typeof allowSpecialUseDomain === 'function') {\n      callback = allowSpecialUseDomain;\n      // TODO: It's weird that `allowSpecialUseDomain` defaults to false with no callback,\n      // but true with a callback. This is legacy behavior from v4.\n      allowSpecialUseDomain = true;\n    }\n    const results = [];\n    const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n    if (!domain) {\n      return promiseCallback.resolve([]);\n    }\n    let pathMatcher;\n    if (!path) {\n      // null means \"all paths\"\n      pathMatcher = function matchAll(domainIndex) {\n        for (const curPath in domainIndex) {\n          const pathIndex = domainIndex[curPath];\n          for (const key in pathIndex) {\n            const value = pathIndex[key];\n            if (value) {\n              results.push(value);\n            }\n          }\n        }\n      };\n    } else {\n      pathMatcher = function matchRFC(domainIndex) {\n        //NOTE: we should use path-match algorithm from S5.1.4 here\n        //(see : https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/canonical_cookie.cc#L299)\n        for (const cookiePath in domainIndex) {\n          if ((0, pathMatch_1.pathMatch)(path, cookiePath)) {\n            const pathIndex = domainIndex[cookiePath];\n            for (const key in pathIndex) {\n              const value = pathIndex[key];\n              if (value) {\n                results.push(value);\n              }\n            }\n          }\n        }\n      };\n    }\n    const domains = (0, permuteDomain_1.permuteDomain)(domain, allowSpecialUseDomain) || [domain];\n    const idx = this.idx;\n    domains.forEach(curDomain => {\n      const domainIndex = idx[curDomain];\n      if (!domainIndex) {\n        return;\n      }\n      pathMatcher(domainIndex);\n    });\n    return promiseCallback.resolve(results);\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  putCookie(cookie, callback) {\n    const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n    const {\n      domain,\n      path,\n      key\n    } = cookie;\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (domain == null || path == null || key == null) {\n      return promiseCallback.resolve(undefined);\n    }\n    const domainEntry = this.idx[domain] ?? Object.create(null);\n    this.idx[domain] = domainEntry;\n    const pathEntry = domainEntry[path] ?? Object.create(null);\n    domainEntry[path] = pathEntry;\n    pathEntry[key] = cookie;\n    return promiseCallback.resolve(undefined);\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  updateCookie(_oldCookie, newCookie, callback) {\n    // updateCookie() may avoid updating cookies that are identical.  For example,\n    // lastAccessed may not be important to some stores and an equality\n    // comparison could exclude that field.\n    // Don't return a value when using a callback, so that the return type is truly \"void\"\n    if (callback) this.putCookie(newCookie, callback);else return this.putCookie(newCookie);\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  removeCookie(domain, path, key, callback) {\n    const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n    delete this.idx[domain]?.[path]?.[key];\n    return promiseCallback.resolve(undefined);\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  removeCookies(domain, path, callback) {\n    const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n    const domainEntry = this.idx[domain];\n    if (domainEntry) {\n      if (path) {\n        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n        delete domainEntry[path];\n      } else {\n        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n        delete this.idx[domain];\n      }\n    }\n    return promiseCallback.resolve(undefined);\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  removeAllCookies(callback) {\n    const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n    this.idx = Object.create(null);\n    return promiseCallback.resolve(undefined);\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  getAllCookies(callback) {\n    const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n    const cookies = [];\n    const idx = this.idx;\n    const domains = Object.keys(idx);\n    domains.forEach(domain => {\n      const domainEntry = idx[domain] ?? {};\n      const paths = Object.keys(domainEntry);\n      paths.forEach(path => {\n        const pathEntry = domainEntry[path] ?? {};\n        const keys = Object.keys(pathEntry);\n        keys.forEach(key => {\n          const keyEntry = pathEntry[key];\n          if (keyEntry != null) {\n            cookies.push(keyEntry);\n          }\n        });\n      });\n    });\n    // Sort by creationIndex so deserializing retains the creation order.\n    // When implementing your own store, this SHOULD retain the order too\n    cookies.sort((a, b) => {\n      return (a.creationIndex || 0) - (b.creationIndex || 0);\n    });\n    return promiseCallback.resolve(cookies);\n  }\n}\nexports.MemoryCookieStore = MemoryCookieStore;","map":{"version":3,"names":["require","Object","defineProperty","exports","value","MemoryCookieStore","pathMatch_1","permuteDomain_1","store_1","utils_1","Store","constructor","synchronous","idx","create","findCookie","domain","path","key","callback","promiseCallback","createPromiseCallback","resolve","undefined","result","findCookies","allowSpecialUseDomain","results","pathMatcher","matchAll","domainIndex","curPath","pathIndex","push","matchRFC","cookiePath","pathMatch","domains","permuteDomain","forEach","curDomain","putCookie","cookie","domainEntry","pathEntry","updateCookie","_oldCookie","newCookie","removeCookie","removeCookies","removeAllCookies","getAllCookies","cookies","keys","paths","keyEntry","sort","a","b","creationIndex"],"sources":["/Users/feyraf/Desktop/projets/Roma/invest/node_modules/tough-cookie/dist/memstore.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MemoryCookieStore = void 0;\nconst pathMatch_1 = require(\"./pathMatch\");\nconst permuteDomain_1 = require(\"./permuteDomain\");\nconst store_1 = require(\"./store\");\nconst utils_1 = require(\"./utils\");\n/**\n * An in-memory {@link Store} implementation for {@link CookieJar}. This is the default implementation used by\n * {@link CookieJar} and supports both async and sync operations. Also supports serialization, getAllCookies, and removeAllCookies.\n * @public\n */\nclass MemoryCookieStore extends store_1.Store {\n    /**\n     * Create a new {@link MemoryCookieStore}.\n     */\n    constructor() {\n        super();\n        this.synchronous = true;\n        this.idx = Object.create(null);\n    }\n    /**\n     * @internal No doc because this is an overload that supports the implementation\n     */\n    findCookie(domain, path, key, callback) {\n        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n        if (domain == null || path == null || key == null) {\n            return promiseCallback.resolve(undefined);\n        }\n        const result = this.idx[domain]?.[path]?.[key];\n        return promiseCallback.resolve(result);\n    }\n    /**\n     * @internal No doc because this is an overload that supports the implementation\n     */\n    findCookies(domain, path, allowSpecialUseDomain = false, callback) {\n        if (typeof allowSpecialUseDomain === 'function') {\n            callback = allowSpecialUseDomain;\n            // TODO: It's weird that `allowSpecialUseDomain` defaults to false with no callback,\n            // but true with a callback. This is legacy behavior from v4.\n            allowSpecialUseDomain = true;\n        }\n        const results = [];\n        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n        if (!domain) {\n            return promiseCallback.resolve([]);\n        }\n        let pathMatcher;\n        if (!path) {\n            // null means \"all paths\"\n            pathMatcher = function matchAll(domainIndex) {\n                for (const curPath in domainIndex) {\n                    const pathIndex = domainIndex[curPath];\n                    for (const key in pathIndex) {\n                        const value = pathIndex[key];\n                        if (value) {\n                            results.push(value);\n                        }\n                    }\n                }\n            };\n        }\n        else {\n            pathMatcher = function matchRFC(domainIndex) {\n                //NOTE: we should use path-match algorithm from S5.1.4 here\n                //(see : https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/canonical_cookie.cc#L299)\n                for (const cookiePath in domainIndex) {\n                    if ((0, pathMatch_1.pathMatch)(path, cookiePath)) {\n                        const pathIndex = domainIndex[cookiePath];\n                        for (const key in pathIndex) {\n                            const value = pathIndex[key];\n                            if (value) {\n                                results.push(value);\n                            }\n                        }\n                    }\n                }\n            };\n        }\n        const domains = (0, permuteDomain_1.permuteDomain)(domain, allowSpecialUseDomain) || [domain];\n        const idx = this.idx;\n        domains.forEach((curDomain) => {\n            const domainIndex = idx[curDomain];\n            if (!domainIndex) {\n                return;\n            }\n            pathMatcher(domainIndex);\n        });\n        return promiseCallback.resolve(results);\n    }\n    /**\n     * @internal No doc because this is an overload that supports the implementation\n     */\n    putCookie(cookie, callback) {\n        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n        const { domain, path, key } = cookie;\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (domain == null || path == null || key == null) {\n            return promiseCallback.resolve(undefined);\n        }\n        const domainEntry = this.idx[domain] ??\n            Object.create(null);\n        this.idx[domain] = domainEntry;\n        const pathEntry = domainEntry[path] ??\n            Object.create(null);\n        domainEntry[path] = pathEntry;\n        pathEntry[key] = cookie;\n        return promiseCallback.resolve(undefined);\n    }\n    /**\n     * @internal No doc because this is an overload that supports the implementation\n     */\n    updateCookie(_oldCookie, newCookie, callback) {\n        // updateCookie() may avoid updating cookies that are identical.  For example,\n        // lastAccessed may not be important to some stores and an equality\n        // comparison could exclude that field.\n        // Don't return a value when using a callback, so that the return type is truly \"void\"\n        if (callback)\n            this.putCookie(newCookie, callback);\n        else\n            return this.putCookie(newCookie);\n    }\n    /**\n     * @internal No doc because this is an overload that supports the implementation\n     */\n    removeCookie(domain, path, key, callback) {\n        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n        delete this.idx[domain]?.[path]?.[key];\n        return promiseCallback.resolve(undefined);\n    }\n    /**\n     * @internal No doc because this is an overload that supports the implementation\n     */\n    removeCookies(domain, path, callback) {\n        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n        const domainEntry = this.idx[domain];\n        if (domainEntry) {\n            if (path) {\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete domainEntry[path];\n            }\n            else {\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete this.idx[domain];\n            }\n        }\n        return promiseCallback.resolve(undefined);\n    }\n    /**\n     * @internal No doc because this is an overload that supports the implementation\n     */\n    removeAllCookies(callback) {\n        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n        this.idx = Object.create(null);\n        return promiseCallback.resolve(undefined);\n    }\n    /**\n     * @internal No doc because this is an overload that supports the implementation\n     */\n    getAllCookies(callback) {\n        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n        const cookies = [];\n        const idx = this.idx;\n        const domains = Object.keys(idx);\n        domains.forEach((domain) => {\n            const domainEntry = idx[domain] ?? {};\n            const paths = Object.keys(domainEntry);\n            paths.forEach((path) => {\n                const pathEntry = domainEntry[path] ?? {};\n                const keys = Object.keys(pathEntry);\n                keys.forEach((key) => {\n                    const keyEntry = pathEntry[key];\n                    if (keyEntry != null) {\n                        cookies.push(keyEntry);\n                    }\n                });\n            });\n        });\n        // Sort by creationIndex so deserializing retains the creation order.\n        // When implementing your own store, this SHOULD retain the order too\n        cookies.sort((a, b) => {\n            return (a.creationIndex || 0) - (b.creationIndex || 0);\n        });\n        return promiseCallback.resolve(cookies);\n    }\n}\nexports.MemoryCookieStore = MemoryCookieStore;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}