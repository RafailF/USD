{"ast":null,"code":"\"use strict\";\n\nconst {\n  domSymbolTree\n} = require(\"./living/helpers/internal-constants\");\nconst SYMBOL_TREE_POSITION = require(\"symbol-tree\").TreePosition;\n\n/**\n * Define a set of properties on an object, by copying the property descriptors\n * from the original object.\n *\n * - `object` {Object} the target object\n * - `properties` {Object} the source from which to copy property descriptors\n */\nexports.define = function define(object, properties) {\n  for (const name of Object.getOwnPropertyNames(properties)) {\n    const propDesc = Object.getOwnPropertyDescriptor(properties, name);\n    Object.defineProperty(object, name, propDesc);\n  }\n};\nexports.mixin = (target, source) => {\n  const keys = Reflect.ownKeys(source);\n  for (let i = 0; i < keys.length; ++i) {\n    if (keys[i] in target) {\n      continue;\n    }\n    Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));\n  }\n};\nlet memoizeQueryTypeCounter = 0;\n\n/**\n * Returns a version of a method that memoizes specific types of calls on the object\n *\n * - `fn` {Function} the method to be memozied\n */\nexports.memoizeQuery = function memoizeQuery(fn) {\n  // Only memoize query functions with arity <= 2\n  if (fn.length > 2) {\n    return fn;\n  }\n  const type = memoizeQueryTypeCounter++;\n  return function (...args) {\n    if (!this._memoizedQueries) {\n      return fn.apply(this, args);\n    }\n    if (!this._memoizedQueries[type]) {\n      this._memoizedQueries[type] = Object.create(null);\n    }\n    let key;\n    if (args.length === 1 && typeof args[0] === \"string\") {\n      key = args[0];\n    } else if (args.length === 2 && typeof args[0] === \"string\" && typeof args[1] === \"string\") {\n      key = args[0] + \"::\" + args[1];\n    } else {\n      return fn.apply(this, args);\n    }\n    if (!(key in this._memoizedQueries[type])) {\n      this._memoizedQueries[type][key] = fn.apply(this, args);\n    }\n    return this._memoizedQueries[type][key];\n  };\n};\nexports.simultaneousIterators = function* (first, second) {\n  for (;;) {\n    const firstResult = first.next();\n    const secondResult = second.next();\n    if (firstResult.done && secondResult.done) {\n      return;\n    }\n    yield [firstResult.done ? null : firstResult.value, secondResult.done ? null : secondResult.value];\n  }\n};\nexports.treeOrderSorter = function (a, b) {\n  const compare = domSymbolTree.compareTreePosition(a, b);\n  if (compare & SYMBOL_TREE_POSITION.PRECEDING) {\n    // b is preceding a\n    return 1;\n  }\n  if (compare & SYMBOL_TREE_POSITION.FOLLOWING) {\n    return -1;\n  }\n\n  // disconnected or equal:\n  return 0;\n};\ntry {\n  exports.Canvas = require(\"canvas\");\n} catch {\n  exports.Canvas = null;\n}","map":{"version":3,"names":["domSymbolTree","require","SYMBOL_TREE_POSITION","TreePosition","exports","define","object","properties","name","Object","getOwnPropertyNames","propDesc","getOwnPropertyDescriptor","defineProperty","mixin","target","source","keys","Reflect","ownKeys","i","length","memoizeQueryTypeCounter","memoizeQuery","fn","type","args","_memoizedQueries","apply","create","key","simultaneousIterators","first","second","firstResult","next","secondResult","done","value","treeOrderSorter","a","b","compare","compareTreePosition","PRECEDING","FOLLOWING","Canvas"],"sources":["/Users/feyraf/Desktop/projets/Roma/invest/node_modules/jsdom/lib/jsdom/utils.js"],"sourcesContent":["\"use strict\";\nconst { domSymbolTree } = require(\"./living/helpers/internal-constants\");\nconst SYMBOL_TREE_POSITION = require(\"symbol-tree\").TreePosition;\n\n/**\n * Define a set of properties on an object, by copying the property descriptors\n * from the original object.\n *\n * - `object` {Object} the target object\n * - `properties` {Object} the source from which to copy property descriptors\n */\nexports.define = function define(object, properties) {\n  for (const name of Object.getOwnPropertyNames(properties)) {\n    const propDesc = Object.getOwnPropertyDescriptor(properties, name);\n    Object.defineProperty(object, name, propDesc);\n  }\n};\n\nexports.mixin = (target, source) => {\n  const keys = Reflect.ownKeys(source);\n  for (let i = 0; i < keys.length; ++i) {\n    if (keys[i] in target) {\n      continue;\n    }\n\n    Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));\n  }\n};\n\nlet memoizeQueryTypeCounter = 0;\n\n/**\n * Returns a version of a method that memoizes specific types of calls on the object\n *\n * - `fn` {Function} the method to be memozied\n */\nexports.memoizeQuery = function memoizeQuery(fn) {\n  // Only memoize query functions with arity <= 2\n  if (fn.length > 2) {\n    return fn;\n  }\n\n  const type = memoizeQueryTypeCounter++;\n\n  return function (...args) {\n    if (!this._memoizedQueries) {\n      return fn.apply(this, args);\n    }\n\n    if (!this._memoizedQueries[type]) {\n      this._memoizedQueries[type] = Object.create(null);\n    }\n\n    let key;\n    if (args.length === 1 && typeof args[0] === \"string\") {\n      key = args[0];\n    } else if (args.length === 2 && typeof args[0] === \"string\" && typeof args[1] === \"string\") {\n      key = args[0] + \"::\" + args[1];\n    } else {\n      return fn.apply(this, args);\n    }\n\n    if (!(key in this._memoizedQueries[type])) {\n      this._memoizedQueries[type][key] = fn.apply(this, args);\n    }\n    return this._memoizedQueries[type][key];\n  };\n};\n\nexports.simultaneousIterators = function* (first, second) {\n  for (;;) {\n    const firstResult = first.next();\n    const secondResult = second.next();\n\n    if (firstResult.done && secondResult.done) {\n      return;\n    }\n\n    yield [\n      firstResult.done ? null : firstResult.value,\n      secondResult.done ? null : secondResult.value\n    ];\n  }\n};\n\nexports.treeOrderSorter = function (a, b) {\n  const compare = domSymbolTree.compareTreePosition(a, b);\n\n  if (compare & SYMBOL_TREE_POSITION.PRECEDING) { // b is preceding a\n    return 1;\n  }\n\n  if (compare & SYMBOL_TREE_POSITION.FOLLOWING) {\n    return -1;\n  }\n\n  // disconnected or equal:\n  return 0;\n};\n\ntry {\n  exports.Canvas = require(\"canvas\");\n} catch {\n  exports.Canvas = null;\n}\n"],"mappings":"AAAA,YAAY;;AACZ,MAAM;EAAEA;AAAc,CAAC,GAAGC,OAAO,CAAC,qCAAqC,CAAC;AACxE,MAAMC,oBAAoB,GAAGD,OAAO,CAAC,aAAa,CAAC,CAACE,YAAY;;AAEhE;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,OAAO,CAACC,MAAM,GAAG,SAASA,MAAMA,CAACC,MAAM,EAAEC,UAAU,EAAE;EACnD,KAAK,MAAMC,IAAI,IAAIC,MAAM,CAACC,mBAAmB,CAACH,UAAU,CAAC,EAAE;IACzD,MAAMI,QAAQ,GAAGF,MAAM,CAACG,wBAAwB,CAACL,UAAU,EAAEC,IAAI,CAAC;IAClEC,MAAM,CAACI,cAAc,CAACP,MAAM,EAAEE,IAAI,EAAEG,QAAQ,CAAC;EAC/C;AACF,CAAC;AAEDP,OAAO,CAACU,KAAK,GAAG,CAACC,MAAM,EAAEC,MAAM,KAAK;EAClC,MAAMC,IAAI,GAAGC,OAAO,CAACC,OAAO,CAACH,MAAM,CAAC;EACpC,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,IAAI,CAACI,MAAM,EAAE,EAAED,CAAC,EAAE;IACpC,IAAIH,IAAI,CAACG,CAAC,CAAC,IAAIL,MAAM,EAAE;MACrB;IACF;IAEAN,MAAM,CAACI,cAAc,CAACE,MAAM,EAAEE,IAAI,CAACG,CAAC,CAAC,EAAEX,MAAM,CAACG,wBAAwB,CAACI,MAAM,EAAEC,IAAI,CAACG,CAAC,CAAC,CAAC,CAAC;EAC1F;AACF,CAAC;AAED,IAAIE,uBAAuB,GAAG,CAAC;;AAE/B;AACA;AACA;AACA;AACA;AACAlB,OAAO,CAACmB,YAAY,GAAG,SAASA,YAAYA,CAACC,EAAE,EAAE;EAC/C;EACA,IAAIA,EAAE,CAACH,MAAM,GAAG,CAAC,EAAE;IACjB,OAAOG,EAAE;EACX;EAEA,MAAMC,IAAI,GAAGH,uBAAuB,EAAE;EAEtC,OAAO,UAAU,GAAGI,IAAI,EAAE;IACxB,IAAI,CAAC,IAAI,CAACC,gBAAgB,EAAE;MAC1B,OAAOH,EAAE,CAACI,KAAK,CAAC,IAAI,EAAEF,IAAI,CAAC;IAC7B;IAEA,IAAI,CAAC,IAAI,CAACC,gBAAgB,CAACF,IAAI,CAAC,EAAE;MAChC,IAAI,CAACE,gBAAgB,CAACF,IAAI,CAAC,GAAGhB,MAAM,CAACoB,MAAM,CAAC,IAAI,CAAC;IACnD;IAEA,IAAIC,GAAG;IACP,IAAIJ,IAAI,CAACL,MAAM,KAAK,CAAC,IAAI,OAAOK,IAAI,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;MACpDI,GAAG,GAAGJ,IAAI,CAAC,CAAC,CAAC;IACf,CAAC,MAAM,IAAIA,IAAI,CAACL,MAAM,KAAK,CAAC,IAAI,OAAOK,IAAI,CAAC,CAAC,CAAC,KAAK,QAAQ,IAAI,OAAOA,IAAI,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;MAC1FI,GAAG,GAAGJ,IAAI,CAAC,CAAC,CAAC,GAAG,IAAI,GAAGA,IAAI,CAAC,CAAC,CAAC;IAChC,CAAC,MAAM;MACL,OAAOF,EAAE,CAACI,KAAK,CAAC,IAAI,EAAEF,IAAI,CAAC;IAC7B;IAEA,IAAI,EAAEI,GAAG,IAAI,IAAI,CAACH,gBAAgB,CAACF,IAAI,CAAC,CAAC,EAAE;MACzC,IAAI,CAACE,gBAAgB,CAACF,IAAI,CAAC,CAACK,GAAG,CAAC,GAAGN,EAAE,CAACI,KAAK,CAAC,IAAI,EAAEF,IAAI,CAAC;IACzD;IACA,OAAO,IAAI,CAACC,gBAAgB,CAACF,IAAI,CAAC,CAACK,GAAG,CAAC;EACzC,CAAC;AACH,CAAC;AAED1B,OAAO,CAAC2B,qBAAqB,GAAG,WAAWC,KAAK,EAAEC,MAAM,EAAE;EACxD,SAAS;IACP,MAAMC,WAAW,GAAGF,KAAK,CAACG,IAAI,CAAC,CAAC;IAChC,MAAMC,YAAY,GAAGH,MAAM,CAACE,IAAI,CAAC,CAAC;IAElC,IAAID,WAAW,CAACG,IAAI,IAAID,YAAY,CAACC,IAAI,EAAE;MACzC;IACF;IAEA,MAAM,CACJH,WAAW,CAACG,IAAI,GAAG,IAAI,GAAGH,WAAW,CAACI,KAAK,EAC3CF,YAAY,CAACC,IAAI,GAAG,IAAI,GAAGD,YAAY,CAACE,KAAK,CAC9C;EACH;AACF,CAAC;AAEDlC,OAAO,CAACmC,eAAe,GAAG,UAAUC,CAAC,EAAEC,CAAC,EAAE;EACxC,MAAMC,OAAO,GAAG1C,aAAa,CAAC2C,mBAAmB,CAACH,CAAC,EAAEC,CAAC,CAAC;EAEvD,IAAIC,OAAO,GAAGxC,oBAAoB,CAAC0C,SAAS,EAAE;IAAE;IAC9C,OAAO,CAAC;EACV;EAEA,IAAIF,OAAO,GAAGxC,oBAAoB,CAAC2C,SAAS,EAAE;IAC5C,OAAO,CAAC,CAAC;EACX;;EAEA;EACA,OAAO,CAAC;AACV,CAAC;AAED,IAAI;EACFzC,OAAO,CAAC0C,MAAM,GAAG7C,OAAO,CAAC,QAAQ,CAAC;AACpC,CAAC,CAAC,MAAM;EACNG,OAAO,CAAC0C,MAAM,GAAG,IAAI;AACvB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}